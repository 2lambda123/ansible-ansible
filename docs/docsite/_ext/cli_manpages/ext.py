"""A CLI docs directives Sphinx extension entry point module.

Usage example:

    .. ansible-cmd-docs:: ansible-playbook
"""

from __future__ import annotations

import typing as t
from os import sep as _fs_path_separator

from docutils import nodes, statemachine
from jinja2 import Environment, FileSystemLoader
from sphinx.util.docutils import SphinxDirective
from sphinx.util.nodes import nested_parse_with_titles

if t.TYPE_CHECKING:
    from sphinx.application import Sphinx

from ._argparse_extractors import generate_cli_jinja2_context
from ._paths import (
    CLI_IMPORTABLES_DIR_PATH,
    TEMPLATES_DIR_PATH,
)


CLI_TEMPLATE_FILENAME = 'cli_rst.j2'
INIT_MODULE_FILENAME = '__init__.py'


def _nodes_from_document_markup_source(
        state: statemachine.State,
        document_source_text: str,
) -> list[nodes.Node]:
    """Turn an RST or Markdown string into a list of nodes.

    These nodes can be used in the document.
    """
    node = nodes.Element()
    node.document = state.document
    nested_parse_with_titles(
        state=state,
        content=statemachine.ViewList(
            statemachine.string2lines(document_source_text),
            source="[ansible autogenerated]",
        ),
        node=node,
    )
    return node.children


class AnsibleCmdDocs(SphinxDirective):
    """Zero-configuration directive ``ansible-cmd-docs`` definition.

    It implements rendering CLI command documentation using a pre-defined
    Jinja2 template. The command is auto-detected by the name of the document
    where the directive is being used.
    """

    has_content = False
    """Flag specifying whether the directive accepts arguments where used."""

    _cli_importable_module_names = list(
        path.name.removesuffix('.py')
        for path in CLI_IMPORTABLES_DIR_PATH.iterdir()
        if path.name != INIT_MODULE_FILENAME and not path.is_dir()
    )
    """List of the importable CLI modules."""

    _jinja2_template = Environment(
        loader=FileSystemLoader(TEMPLATES_DIR_PATH),
    ).get_template(CLI_TEMPLATE_FILENAME)
    """Reusable pre-loaded Jinja2 template being rendered in the directive."""

    def _make_doctree_cache_depend_on(self, *paths) -> None:
        for path in paths:
            self.env.note_dependency(str(path))

    def run(self) -> t.List[nodes.Node]:
        """Generate a node tree in place of the directive.

        It determines the CLI command, and the Python class and module
        names from the current Sphinx document name. It also uses said
        Python module, this extension module itself and the template for
        Sphinx's built-in document cache invalidation.
        """
        cli_bin_name = self.env.docname.rsplit(_fs_path_separator)[1]

        jinja2_ctx = generate_cli_jinja2_context(cli_bin_name)
        assert jinja2_ctx['cli'] in self._cli_importable_module_names

        self._make_doctree_cache_depend_on(
            __file__,
            TEMPLATES_DIR_PATH / CLI_TEMPLATE_FILENAME,
            CLI_IMPORTABLES_DIR_PATH / INIT_MODULE_FILENAME,
            CLI_IMPORTABLES_DIR_PATH / f'{jinja2_ctx["cli"]}.py',
        )

        cmd_rst_document = self._jinja2_template.render(jinja2_ctx)
        return _nodes_from_document_markup_source(
            state=self.state,
            document_source_text=cmd_rst_document,
        )


def setup(app: Sphinx) -> t.Dict[str, t.Union[bool, str]]:
    """Initialize the Sphinx extension."""
    app.add_directive('ansible-cmd-docs', AnsibleCmdDocs)

    return {
        'parallel_read_safe': True,
        'parallel_write_safe': True,
        'version': 'builtin',
    }
