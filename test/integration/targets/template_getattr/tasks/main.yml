- name: "show the valid_test data for reference"
  debug:
    var: valid_test


- name: "Try to access a data item called 'get' that shows a builtin. Expect it to return the item and a warning"
  debug:
    msg: "valid_test.get {{ valid_test.get }}"

- name: "Try to access a data item called 'get' that shows a builtin. Expect it to return the item and a warning"
  assert:
    that:
      - valid_test.get != "is_get_valid"
      - valid_test.get is callable


- name: "Try to access a data item called 'get' via ['get'] that shadows a builtin. Expect it to return the item but without a warning"
  debug:
    msg: "valid_test['get'] {{ valid_test['get'] }}"

- name: "Assert access to a data item called 'get' via ['get'] that shadows a builtin. Expect it to return the item but without a warning"
  assert:
    that:
      - valid_test['get'] == "is_get_valid"


- name: "Try to access a nested dict with via .get. This shadows a builtin so expect the item returned and a warning"
  debug:
    msg: "l4.get: {{ valid_test.level2.level3.level4.get }}"

- name: "Assert access to a nested dict with via .get. This shadows a builtin so expect the method returned and a warning"
  assert:
    that:
      - valid_test.level2.level3.level4.get != "level4_get"
      - valid_test.level2.level3.level4.get is callable


- name: "Try to access a nested dict with via ['item']. This shadows a builtin but uses getitem so expect the item returned and no warning"
  debug:
    msg: "l4 item: {{valid_test['level2']['level3']['level4']['get'] }}"

- name: "Assert access to a nested dict with via ['item']. This shadows a builtin but uses getitem so expect the item returned and no warning"
  assert:
    that:
      - valid_test['level2']['level3']['level4']['get'] == "level4_get"


- name: "Try to access and valid_test['some_var'].startswith and call it (builtin). Not shadowed, so no warning."
  debug:
    msg: "valid_test['some_var'].startswith('fo'): {{ valid_test['some_var'].startswith('fo') }}"

- name: "Assert access to valid_test['some_var'].startswith and call it (builtin). Not shadowed, so no warning."
  assert:
    that:
      - valid_test['some_var'].startswith('fo') == false


- name: "Try to access and valid_test.some_var.startswith and call it (builtin). Not shadowed, so no warning."
  debug:
    msg: "valid_test.some_var.startswith('r_v'): {{ valid_test.some_var.startswith('r_v') }}"

- name: "Assert access to valid_test.some_var.startswith and call it (builtin). Not shadowed, so no warning."
  assert:
    that:
      - valid_test.some_var.startswith('r_v') == false


- name: "Try to access and call a builtin method (upper). This is not shadowed so expect it to return can call without a warning."
  debug:
    msg: "valid_test.some_var.upper(): {{ valid_test.some_var.upper() }}"


- name: "Assert access and call a builtin method (upper). This is not shadowed so expect it to be accessed and called without a warning."
  assert:
    that:
      - valid_test.some_var.upper() == "SOME_VAR_V"

- name: "Try to call valid_test.get(), but 'get' is a data item that shadows a builtin method and the method is returned and called and a warning"
  assert:
    that:
      - valid_test.get('some_var') == 'some_var_v'

- debug:
    var: valid_test.values

- debug:
    var: valid_test.values()

- name: Try to access a item that doesnt exist as attr or item so it fails.
  debug:
    msg: "valid_test.not_a_key: {{ valid_test.not_a_key }}"
  ignore_errors: true

- name: "Try to access a item via ['not_a_key'] but not_a_key does not exist as attr or item so it fails."
  debug:
    msg: "valid_test['not_a_key']: {{ valid_test['not_a_key'] }}"
  ignore_errors: true

- name: "Try to access valid_list.a_list.count (builtin method) but it is not shadowed so it works"
  debug:
    msg: "valid_test.a_list.count: {{ valid_test.a_list.count }}"

- name: "Try to access and call valid_list.a_list.count() (builtin method) but it is not shadowed so it works"
  debug:
    msg: "valid_test.a_list.count(): {{ valid_test.a_list.count('thing 1') }}"

- name: "Assert that access and call valid_list.a_list.count() (builtin method) but it is not shadowed so it works"
  assert:
    that:
      - valid_test.a_list.count('thing 1') == 1

- name: "Try to access valid_list.a_list.pop (builtin method) but it is not shadowed so it works"
  debug:
    msg: "valid_test.a_list.pop: {{ valid_test.a_list.pop }}"

- name: "Try to access and call valid_list.a_list.pop() (builtin method) but it is not shadowed so it works"
  debug:
    msg: "valid_test.a_list.pop(): {{ valid_test.a_list.pop() }}"

- name: "Try to access and call valid_list.a_list.pop() (builtin method) but it is not shadowed so it works"
  assert:
    that:
      - valid_test.a_list.pop() == "thing 3"

- name: "Try to access valid_list.confused_for_list.pop which is an item so expect the 'pop' method to be returned with a warning"
  debug:
    msg: "valid_test.confused_for_a_list.pop: {{ valid_test.confused_for_a_list.pop }}"

- name: "Try to access valid_list.confused_for_list.pop which is an item so expect the 'pop' method to be returned with a warning"
  assert:
    that:
      - valid_test.confused_for_a_list.pop != "cheerwine"
      - valid_test.confused_for_a_list.pop is callable

- name: "Try to access valid_list.confused_for_list.popitem (builtin method) and expect the method to be returned without a warning"
  debug:
    msg: "valid_test.confused_for_a_list.popitem: {{ valid_test.confused_for_a_list.popitem }}"

- name: "Try to access valid_list.confused_for_list.popitem (builtin method) and expect the method object to be returned without a warning"
  assert:
    that:
      - valid_test.confused_for_a_list.popitem != "foo"

- name: "Try to access and call valid_list.confused_for_list.popitem (builtin method) and expect the method to be returned and called without a warning"
  debug:
    msg: "valid_test.confused_for_a_list.popitem(): {{ valid_test.confused_for_a_list.popitem() }}"
    # built-in method popitem

- name: "Try to access and call valid_list.confused_for_list.popitem (builtin method) and expect the method to be accessed and called without a warning"
  assert:
    that:
      - valid_test.confused_for_a_list.popitem()[0] in ['pop', 'soda']
      - valid_test.confused_for_a_list.popitem()[1] in ['cheerwine', 'RC']

      # these fail with or without the pat
- debug:
    msg: "valid_test.endswith: {{ valid_test.endswith }}"

- debug:
    msg: "valid_test.some_var.endswith: {{ valid_test.some_var.endswith }}"

- debug:
    msg: "valid_test.some_var.endswith('r_v'): {{ valid_test.some_var.endswith('r_v') }}"

- assert:
    that:
      - valid_test.some_var.endswith is callable
      - valid_test.some_var.endswith('r_v') == True
      - valid_test.some_var.endswith('the_end') == False

- name: try confused.endswith
  assert:
    that:
      - valid_test.confused.endswith is not callable
      - valid_test.confused.endswith == "not the endswith method"

