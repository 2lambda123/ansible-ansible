# Create basic CSV file
- name: Create unique CSV file
  copy:
    content: |
      name,uid,gid,gecos
      dag,500,500,Dag Wieërs
      jeroen,501,500,Jeroen Hoekx
    dest: users_unique.csv

# Read a CSV file and access user 'dag'
- name: Read users from CSV file and return a dictionary
  read_csv:
    path: users_unique.csv
    key: name
  register: users_unique

- assert:
    that:
    - users_unique.dict.dag.name == 'dag'
    - users_unique.dict.dag.gecos == 'Dag Wieërs'
    - users_unique.dict.dag.uid == '500'
    - users_unique.dict.dag.gid == '500'
    - users_unique.dict.jeroen.name == 'jeroen'
    - users_unique.dict.jeroen.gecos == 'Jeroen Hoekx'
    - users_unique.dict.jeroen.uid == '501'
    - users_unique.dict.jeroen.gid == '500'

 # Read a CSV file and access the first item
- name: Read users from CSV file and return a list
  read_csv:
    path: users_unique.csv
  register: users_unique

- assert:
    that:
    - users_unique.list.0.name == 'dag'
    - users_unique.list.0.gecos == 'Dag Wieërs'
    - users_unique.list.0.uid == '500'
    - users_unique.list.0.gid == '500'
    - users_unique.list.1.name == 'jeroen'
    - users_unique.list.1.gecos == 'Jeroen Hoekx'
    - users_unique.list.1.uid == '501'
    - users_unique.list.1.gid == '500'


# Create basic CSV file using semi-colon
- name: Create non-unique CSV file using semi-colon
  copy:
    content: |
      name;uid;gid;gecos
      dag;500;500;Dag Wieërs
      jeroen;501;500;Jeroen Hoekx
      dag;502;500;Dag Wieers
    dest: users_nonunique.csv

# Read a CSV file and access user 'dag'
- name: Read users from CSV file and return a dictionary
  read_csv:
    path: users_nonunique.csv
    key: name
    unique: no
    delimiter: ';'
  register: users_nonunique

- assert:
    that:
    - users_nonunique.dict.dag.name == 'dag'
    - users_nonunique.dict.dag.gecos == 'Dag Wieers'
    - users_nonunique.dict.dag.uid == '502'
    - users_nonunique.dict.dag.gid == '500'
    - users_nonunique.dict.jeroen.name == 'jeroen'
    - users_nonunique.dict.jeroen.gecos == 'Jeroen Hoekx'
    - users_nonunique.dict.jeroen.uid == '501'
    - users_nonunique.dict.jeroen.gid == '500'


# Read a CSV file using an non-existing dialect
- name: Read users from CSV file and return a dictionary
  read_csv:
    path: users_nonunique.csv
    dialect: placebo
  register: users_placebo
  ignore_errors: yes

- assert:
    that:
    - users_placebo is failed
    - users_placebo.msg == "Dialect 'placebo' is not supported by your version of python."


# Create basic CSV file without header
- name: Create unique CSV file without header
  copy:
    content: |
      dag,500,500,Dag Wieërs
      jeroen,501,500,Jeroen Hoekx
    dest: users_noheader.csv

# Read a CSV file and access user 'dag'
- name: Read users from CSV file and return a dictionary
  read_csv:
    path: users_noheader.csv
    key: name
    fieldnames: name,uid,gid,gecos
  register: users_noheader

- assert:
    that:
    - users_noheader.dict.dag.name == 'dag'
    - users_noheader.dict.dag.gecos == 'Dag Wieërs'
    - users_noheader.dict.dag.uid == '500'
    - users_noheader.dict.dag.gid == '500'
    - users_noheader.dict.jeroen.name == 'jeroen'
    - users_noheader.dict.jeroen.gecos == 'Jeroen Hoekx'
    - users_noheader.dict.jeroen.uid == '501'
    - users_noheader.dict.jeroen.gid == '500'


# Crate a CSV file with fields containing line breaks
- name: Create security rules CSV file
  copy:
    content: |
      name,protocol,source_address_prefix,destination_port_range,access,priority,direction
      DenySSH,Tcp,Internet,22,Deny,100,Inbound
      AllowSSH,Tcp,"174.109.158.0/24
      174.109.159.0/24",22,Allow,101,Inbound
      AllowMultiplePorts,Tcp,"174.109.158.0/24
      174.109.159.0/24","80
      443",Allow,102,Inbound
    dest: security_rules.csv

# Read a CSV file with fields containing line breaks
- name: Read security rules from CSV file and return a list
  read_csv:
    path: security_rules.csv
    splitlinebreaks: yes
  register: security_rules

- assert:
    that:
    - security_rules.list.0.name == 'DenySSH'
    - security_rules.list.0.protocol == 'Tcp'
    - security_rules.list.0.source_address_prefix == 'Internet'
    - security_rules.list.0.destination_port_range == '22'
    - security_rules.list.0.access == 'Deny'
    - security_rules.list.0.priority == '100'
    - security_rules.list.0.direction == 'Inbound'
    - security_rules.list.1.name == 'AllowSSH'
    - security_rules.list.1.protocol == 'Tcp'
    - security_rules.list.1.source_address_prefix == ['174.109.158.0/24', '174.109.159.0/24']
    - security_rules.list.1.destination_port_range == '22'
    - security_rules.list.1.access == 'Allow'
    - security_rules.list.1.priority == '101'
    - security_rules.list.1.direction == 'Inbound'
    - security_rules.list.2.name == 'AllowMultiplePorts'
    - security_rules.list.2.protocol == 'Tcp'
    - security_rules.list.2.source_address_prefix == ['174.109.158.0/24', '174.109.159.0/24']
    - security_rules.list.2.destination_port_range == ['80', '443']
    - security_rules.list.2.access == 'Allow'
    - security_rules.list.2.priority == '102'
    - security_rules.list.2.direction == 'Inbound'

# Read a CSV file with fields containing line breaks
- name: Read security rules from CSV file and return a dictionary
  read_csv:
    path: security_rules.csv
    key: name
    splitlinebreaks: yes
  register: security_rules

- assert:
    that:
    - security_rules.dict.DenySSH.name == 'DenySSH'
    - security_rules.dict.DenySSH.protocol == 'Tcp'
    - security_rules.dict.DenySSH.source_address_prefix == 'Internet'
    - security_rules.dict.DenySSH.destination_port_range == '22'
    - security_rules.dict.DenySSH.access == 'Deny'
    - security_rules.dict.DenySSH.priority == '100'
    - security_rules.dict.DenySSH.direction == 'Inbound'
    - security_rules.dict.AllowSSH.name == 'AllowSSH'
    - security_rules.dict.AllowSSH.protocol == 'Tcp'
    - security_rules.dict.AllowSSH.source_address_prefix == ['174.109.158.0/24', '174.109.159.0/24']
    - security_rules.dict.AllowSSH.destination_port_range == '22'
    - security_rules.dict.AllowSSH.access == 'Allow'
    - security_rules.dict.AllowSSH.priority == '101'
    - security_rules.dict.AllowSSH.direction == 'Inbound'
    - security_rules.dict.AllowMultiplePorts.name == 'AllowMultiplePorts'
    - security_rules.dict.AllowMultiplePorts.protocol == 'Tcp'
    - security_rules.dict.AllowMultiplePorts.source_address_prefix == ['174.109.158.0/24', '174.109.159.0/24']
    - security_rules.dict.AllowMultiplePorts.destination_port_range == ['80', '443']
    - security_rules.dict.AllowMultiplePorts.access == 'Allow'
    - security_rules.dict.AllowMultiplePorts.priority == '102'
    - security_rules.dict.AllowMultiplePorts.direction == 'Inbound'


# Create broken file
- name: Create unique CSV file
  copy:
    content: |
      name,uid,gid,gecos
      dag,500,500,Dag Wieërs
      jeroen,501,500,"Jeroen"Hoekx"
    dest: users_broken.csv

# Read a broken CSV file using strict
- name: Read users from a broken CSV file
  read_csv:
    path: users_broken.csv
    key: name
    strict: yes
  register: users_broken
  ignore_errors: yes

- assert:
    that:
    - users_broken is failed
    - "'Unable to process file' in users_broken.msg"
