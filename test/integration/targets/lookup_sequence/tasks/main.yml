- name: test with_sequence
  set_fact: "{{ 'x' + item }}={{ item }}"
  with_sequence: start=0 end=3

- name: test with_sequence backwards
  set_fact: "{{ 'y' + item }}={{ item }}"
  with_sequence: start=3 end=0 stride=-1

- name: verify with_sequence
  assert:
    that:
        - "x0 == '0'"
        - "x1 == '1'"
        - "x2 == '2'"
        - "x3 == '3'"
        - "y3 == '3'"
        - "y2 == '2'"
        - "y1 == '1'"
        - "y0 == '0'"

- name: test with_sequence not failing on count == 0
  debug: msg='previously failed with backward counting error'
  with_sequence: count=0
  register: count_of_zero

- name: test with_sequence does 1 when start == end
  debug: msg='should run once'
  with_sequence: start=1 end=1
  register: start_equal_end

- name: test with_sequence count 1
  set_fact: "{{ 'x' + item }}={{ item }}"
  with_sequence: count=1
  register: count_of_one

- assert:
    that:
        - start_equal_end is not skipped
        - count_of_zero is skipped
        - count_of_one is not skipped

- name: test with_sequence shortcut syntax (end)
  set_fact: "{{ 'ws_z_' + item }}={{ item }}"
  with_sequence: '4'

- name: test with_sequence shortcut syntax (start-end/stride)
  set_fact: "{{ 'ws_z_' + item }}=stride_{{ item }}"
  with_sequence: '2-6/2'

- name: test with_sequence shortcut syntax (start-end:format)
  set_fact: "{{ 'ws_z_' + item }}={{ item }}"
  with_sequence: '7-8:host%02d'

- name: verify with_sequence shortcut syntax
  assert:
    that:
        - "ws_z_1 == '1'"
        - "ws_z_2 == 'stride_2'"
        - "ws_z_3 == '3'"
        - "ws_z_4 == 'stride_4'"
        - "ws_z_6 == 'stride_6'"
        - "ws_z_host07 == 'host07'"
        - "ws_z_host08 == 'host08'"

- block:
    - name: EXPECTED FAILURE - test invalid arg
      set_fact: "{{ 'x' + item }}={{ item }}"
      with_sequence: start=0 junk=3

    - fail:
        msg: "should not get here"
  rescue:
    - assert:
        that:
          - ansible_failed_task.name == "EXPECTED FAILURE - test invalid arg"
          - ansible_failed_result.msg in [expected1, expected2]
      vars:
        expected1: "unrecognized arguments to with_sequence: ['junk']"
        expected2: "unrecognized arguments to with_sequence: [u'junk']"

- block:
    - name: EXPECTED FAILURE - test bad kv value
      set_fact: "{{ 'x' + item }}={{ item }}"
      with_sequence: start=A end=3

    - fail:
        msg: "should not get here"
  rescue:
    - assert:
        that:
          - ansible_failed_task.name == "EXPECTED FAILURE - test bad kv value"
          - ansible_failed_result.msg.startswith("Invalid type for")

- block:
    - name: EXPECTED FAILURE - test bad simple form start value
      set_fact: "{{ 'x' + item }}={{ item }}"
      with_sequence: A-4/2

    - fail:
        msg: "should not get here"
  rescue:
    - assert:
        that:
          - ansible_failed_task.name == "EXPECTED FAILURE - test bad simple form start value"
          - ansible_failed_result.msg.startswith("Invalid type for")

- block:
    - name: EXPECTED FAILURE - test bad simple form end value
      set_fact: "{{ 'x' + item }}={{ item }}"
      with_sequence: 1-B/2

    - fail:
        msg: "should not get here"
  rescue:
    - assert:
        that:
          - ansible_failed_task.name == "EXPECTED FAILURE - test bad simple form end value"
          - ansible_failed_result.msg.startswith("Invalid type for")

- block:
    - name: EXPECTED FAILURE - test bad simple form stride value
      set_fact: "{{ 'x' + item }}={{ item }}"
      with_sequence: 1-4/C

    - fail:
        msg: "should not get here"
  rescue:
    - assert:
        that:
          - ansible_failed_task.name == "EXPECTED FAILURE - test bad simple form stride value"
          - ansible_failed_result.msg.startswith("Invalid type for")

- block:
    - name: EXPECTED FAILURE - test no count or end
      set_fact: "{{ 'x' + item }}={{ item }}"
      with_sequence: start=1

    - fail:
        msg: "should not get here"
  rescue:
    - assert:
        that:
          - ansible_failed_task.name == "EXPECTED FAILURE - test no count or end"
          - ansible_failed_result.msg == "must specify count or end in with_sequence"

- block:
    - name: EXPECTED FAILURE - test both count and end
      set_fact: "{{ 'x' + item }}={{ item }}"
      with_sequence: start=1 end=4 count=2

    - fail:
        msg: "should not get here"
  rescue:
    - assert:
        that:
          - ansible_failed_task.name == "EXPECTED FAILURE - test both count and end"
          - ansible_failed_result.msg == "can't specify both count and end in with_sequence"

- block:
    - name: EXPECTED FAILURE - test count backwards message
      set_fact: "{{ 'x' + item }}={{ item }}"
      with_sequence: start=4 end=1 stride=2

    - fail:
        msg: "should not get here"
  rescue:
    - assert:
        that:
          - ansible_failed_task.name == "EXPECTED FAILURE - test count backwards message"
          - ansible_failed_result.msg == "to count backwards make stride negative"

- block:
    - name: EXPECTED FAILURE - test count forward message
      set_fact: "{{ 'x' + item }}={{ item }}"
      with_sequence: start=1 end=4 stride=-2

    - fail:
        msg: "should not get here"
  rescue:
    - assert:
        that:
          - ansible_failed_task.name == "EXPECTED FAILURE - test count forward message"
          - ansible_failed_result.msg == "to count forward don't make stride negative"

- block:
    - name: EXPECTED FAILURE - test bad format string message
      set_fact: "{{ 'x' + item }}={{ item }}"
      with_sequence: start=1 end=4 format=d

    - fail:
        msg: "should not get here"
  rescue:
    - assert:
        that:
          - ansible_failed_task.name == "EXPECTED FAILURE - test bad format string message"
          - ansible_failed_result.msg == expected
      vars:
        expected: "bad formatting string: d"

# Tests for lookup()/plugin() jinja invocation:
# Many of these tests check edge case behaviors that are only possible when invoking query/lookup sequence through jinja.
# While they aren't particularly intuitive, these tests ensure playbooks that could be relying on these behaviors don't
# break in future
- name: Test that sequence can be invoked using query/lookup with keyword args only
  ping:
    data: '{{ item }}'
  loop: '{{ query("ansible.builtin.sequence", count=5, start=10) }}'
  register: results1

- name: Assert that sequence can be invoked using query/lookup with keyword args only
  assert:
    that:
      - 'results1["results"][0]["ping"] == "10"'
      - 'results1["results"][1]["ping"] == "11"'
      - 'results1["results"][2]["ping"] == "12"'
      - 'results1["results"][3]["ping"] == "13"'
      - 'results1["results"][4]["ping"] == "14"'

- name: Test that multiple positional args produces concatenated sequence
  ping:
    data: '{{ item }}'
  loop: '{{ query("ansible.builtin.sequence", "count=5 start=1", "count=3 start=10 stride=2") }}'
  register: results2

- name: Assert that multiple positional args produces concatenated sequence
  assert:
    that:
      - 'results2["results"][0]["ping"] == "1"'
      - 'results2["results"][1]["ping"] == "2"'
      - 'results2["results"][2]["ping"] == "3"'
      - 'results2["results"][3]["ping"] == "4"'
      - 'results2["results"][4]["ping"] == "5"'
      - 'results2["results"][5]["ping"] == "10"'
      - 'results2["results"][6]["ping"] == "12"'
      - 'results2["results"][7]["ping"] == "14"'

- name: Test that keyword arguments are applied to all positional expressions
  ping:
    data: '{{ item }}'
  loop: '{{ query("ansible.builtin.sequence", "count=5 start=0", "count=5 start=20", stride=2) }}'
  register: results3

- name: Assert that keyword arguments are applied to all positional expressions
  assert:
    that:
      - 'results3["results"][0]["ping"] == "0"'
      - 'results3["results"][1]["ping"] == "2"'
      - 'results3["results"][2]["ping"] == "4"'
      - 'results3["results"][3]["ping"] == "6"'
      - 'results3["results"][4]["ping"] == "8"'
      - 'results3["results"][5]["ping"] == "20"'
      - 'results3["results"][6]["ping"] == "22"'
      - 'results3["results"][7]["ping"] == "24"'
      - 'results3["results"][8]["ping"] == "26"'
      - 'results3["results"][9]["ping"] == "28"'

- name: Test that keyword arguments do not overwrite parameters present in positional expressions
  ping:
    data: '{{ item }}'
  loop: '{{ query("ansible.builtin.sequence", "count=5 start=0", "count=5", start=20) }}'
  register: results4

- name: Assert that keyword arguments do not overwrite parameters present in positional expressions
  assert:
    that:
      - 'results4["results"][0]["ping"] == "0"'
      - 'results4["results"][1]["ping"] == "1"'
      - 'results4["results"][2]["ping"] == "2"'
      - 'results4["results"][3]["ping"] == "3"'
      - 'results4["results"][4]["ping"] == "4"'
      - 'results4["results"][5]["ping"] == "20"'
      - 'results4["results"][6]["ping"] == "21"'
      - 'results4["results"][7]["ping"] == "22"'
      - 'results4["results"][8]["ping"] == "23"'
      - 'results4["results"][9]["ping"] == "24"'

- name: Test that call with no arguments produces an empty list
  ping:
    data: '{{ item }}'
  loop: '{{ query("ansible.builtin.sequence") }}'
  register: results5

- name: Assert that call with no arguments produces an empty list
  assert:
    that:
      - 'results5["results"] == []'
