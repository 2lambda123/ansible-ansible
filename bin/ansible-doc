#!/usr/bin/env python

# (c) 2012, Jan-Piet Mens <jpmens () gmail.com>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#

import os
import sys
import yaml
import json
import ast
import textwrap
import re
import optparse
import time
import datetime
from ansible import utils
from ansible import errors
from ansible.utils import module_docs
import ansible.constants as C

MODULEDIR = C.DEFAULT_MODULE_PATH

_ITALIC = re.compile(r"I\(([^)]+)\)")
_BOLD   = re.compile(r"B\(([^)]+)\)")
_MODULE = re.compile(r"M\(([^)]+)\)")
_URL    = re.compile(r"U\(([^)]+)\)")
_CONST  = re.compile(r"C\(([^)]+)\)")


def check_outputtype(outputtype="console"):
    # If the outputtype is not supported, exit
    if outputtype != "markdown" and outputtype != "console":
        sys.stderr.write("ERROR: Output type '%s' is not supported!\n" % outputtype)
	sys.exit(1)


def set_output_tags(outputtype="console"):

    tags = {}
    if outputtype == "console":
        tags["wrap"] = True  # Wrap text

        tags["ch"] = ">"     # Chapter '>'
        tags["pa"] = ""      # Paragraph ''
        tags["ma"] = "="     # Mandatory tag
        tags["mas"]= ""      # Mandatory start
        tags["mae"]= ""      # Mandatory end
        tags["lst"] = ""     # Unordered list tag

        tags["is"] = "`"     # I(word) => `word'
        tags["ie"] = "'"     # I(word) => `word'
        tags["bs"] = "*"     # B(word) => *word*
        tags["be"] = "*"     # B(word) => *word*
        tags["ms"] = "["     # M(word) => [word]
        tags["me"] = "]"     # M(word) => [word]
        tags["cs"] = "`"     # C(word) => `word'
        tags["ce"] = "'"     # C(word) => `word'
        tags["us"] = ""      # U(word) =>  word
        tags["ue"] = ""      # U(word) =>  word

    if outputtype == "markdown":
        tags["wrap"] = False # Wrap text

        tags["ch"] = "# "    # Chapter '#'
        tags["pa"] = "## "   # Paragraph '##'
        tags["ma"] = "-"     # Mandatory tag
        tags["mas"]= "**"    # Mandatory start
        tags["mae"]= "**"    # Mandatory end
        tags["lst"] = "* "   # Unordered list tag

        tags["is"] = "*"     # I(word) => *word*
        tags["ie"] = "*"     # I(word) => *word*
        tags["bs"] = "**"    # B(word) => **word**
        tags["be"] = "**"    # B(word) => **word**
        tags["ms"] = "[*"    # M(word) => [*word*]
        tags["me"] = "*]"    # M(word) => [*word*]
        tags["cs"] = "`"     # C(word) => `word`
        tags["ce"] = "`"     # C(word) => `word`
        tags["us"] = "<"     # U(word) => <word>
        tags["ue"] = ">"     # U(word) => <word>

    return tags


def tty_ify(text, outputtype="console"):

    tags = set_output_tags(outputtype)

    t = _ITALIC.sub( tags["is"] + r"\1" + tags["ie"], text)
    t = _BOLD.sub(   tags["bs"] + r"\1" + tags["be"], t)
    t = _MODULE.sub( tags["ms"] + r"\1" + tags["me"], t)
    t = _CONST.sub(  tags["cs"] + r"\1" + tags["ce"], t)
    t = _URL.sub(    tags["us"] + r"\1" + tags["ue"], t)

    return t


def print_man(doc, outputtype="console"):

    tags = set_output_tags(outputtype)

    opt_indent="        "
    print "%s%s\n" % (tags["ch"], doc['module'].upper())

    desc = "".join(doc['description'])

    if tags["wrap"]:
        print "%s\n" % textwrap.fill(tty_ify(desc, outputtype), initial_indent="  ", subsequent_indent="  ")
    else:
        print "%s\n" % tty_ify(desc, outputtype)
    print "%sOptions (%s%s%s is mandatory):\n" % (tags["pa"], tags["mas"], tags["ma"], tags["mae"])

    for o in doc['option_keys']:
        opt = doc['options'][o]

        if opt.get('required', False):
            print "%s %s" % ("-", o)
        else:
            print "%s %s%s%s" % (tags["ma"], tags["mas"], o, tags["mae"])

        desc = "".join(opt['description'])

        if 'choices' in opt:
            choices = ", ".join(opt['choices'])
            desc = desc + " (Choices: " + choices + ")"

	if tags["wrap"]:
            print "%s\n" % textwrap.fill(tty_ify(desc, outputtype),
	                        initial_indent=opt_indent,
                                subsequent_indent=opt_indent)
        else:
            print "%s\n" % tty_ify(desc, outputtype)

    if 'notes' in doc:
        notes = "".join(doc['notes'])
	if tags["wrap"]:
            print "Notes:%s\n" % textwrap.fill(tty_ify(notes, outputtype),
	                        initial_indent="  ",
                                subsequent_indent=opt_indent)
        else:
            print "%sNotes\n\n%s\n" % (tags["pa"], tty_ify(notes, outputtype))

    if 'examples' in doc:
	print "%sExamples\n" % tags["pa"]

        for ex in doc['examples']:
                print "%s%s" % (opt_indent, ex['code'])


def print_snippet(doc, outputtype):

    desc = tty_ify("".join(doc['short_description']), outputtype)
    print "- name: %s" % (desc)
    print "  action: %s" % (doc['module'])

    for o in doc['options']:
        opt = doc['options'][o]
        desc = tty_ify("".join(opt['description']), outputtype)
        s = o + "="
        print "      %-20s   # %s" % (s, desc[0:60])


def main():

    p = optparse.OptionParser(
        version='%prog 1.0',
        usage='usage: %prog [options] [module...]',
        description='Show Ansible module documentation',
    )

    p.add_option("-M", "--module-path",
            action="store",
            dest="module_path",
            default=MODULEDIR,
            help="Ansible modules/ directory")
    p.add_option("-l", "--list",
            action="store_true",
            default=False,
            dest='list_dir',
            help='List available modules')
    p.add_option("-s", "--snippet",
            action="store_true",
            default=False,
            dest='show_snippet',
            help='Show playbook snippet for specified module(s)')
    p.add_option("-o", "--output-type",
            action="store",
	    dest="outputtype",
	    type="string",
            default="console",
            help='Output type (console|markdown). Default: console')
    p.add_option('-v', action='version', help='Show version number and exit')

    (options, args) = p.parse_args()

    check_outputtype(options.outputtype)
    tags = set_output_tags(options.outputtype)

    if options.module_path is not None:
        utils.plugins.vars_loader.add_directory(options.module_path)

    if options.list_dir:
        # list all modules
        paths = utils.plugins.module_finder._get_paths()
        module_list = []
        for path in paths:
            # os.system("ls -C %s" % (path))
            if os.path.isdir(path):
                for module in os.listdir(path):
                    module_list.append(module)

        for module in sorted(module_list):

            if module in module_docs.BLACKLIST_MODULES:
                continue

            filename = utils.plugins.module_finder.find_plugin(module)
            try:
                doc = utils.module_docs.get_docstring(filename)
                desc = tty_ify(doc.get('short_description', '?'), options.outputtype)
		if tags["wrap"]:
                    if len(desc) > 55:
                        desc = desc + '...'
                    print "%s%-20s %-60.60s" % (tags["lst"], module, desc)
	        else:
                    print "%s%-20s %s" % (tags["lst"], module, desc)
            except:
                sys.stderr.write("ERROR: module %s missing documentation\n" % module)
                pass

        sys.exit()

    module_list = []

    if len(args) == 0:
        p.print_help()

    for module in args:

        filename = utils.plugins.module_finder.find_plugin(module)
        if filename is None:
            sys.stderr.write("module %s not found in %s\n" % (module,
                    utils.plugins.module_finder.print_paths()))
            continue

        if filename.endswith(".swp"):
            continue

        try:
            doc = utils.module_docs.get_docstring(filename)
        except:
            sys.stderr.write("ERROR: module %s missing documentation\n" % module)
            continue

        if not doc is None:

            all_keys = []
            for (k,v) in doc['options'].iteritems():
                all_keys.append(k)
            all_keys = sorted(all_keys)

            doc['option_keys'] = all_keys
            doc['filename']    = filename
            doc['docuri']      = doc['module'].replace('_', '-')
            doc['now_date']    = datetime.date.today().strftime('%Y-%m-%d')

            if options.show_snippet:
                print_snippet(doc, outputtype=options.outputtype)
            else:
                print_man(doc, outputtype=options.outputtype)
        else:
            sys.stderr.write("ERROR: module %s missing documentation\n" % module)

if __name__ == '__main__':
    main()
