#!/usr/bin/python
# -*- coding: utf-8 -*-

# (c) 2012, Red Hat, inc
# Written by Seth Vidal
# based on the mount modules from salt and puppet
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

DOCUMENTATION = '''
---
module: mount
short_description: Control active and configured mount points
description:
     - This module controls active and configured mount points in C(/etc/fstab).
version_added: "0.6"
options:
  name:
    description:
      - "path to the mount point, eg: C(/mnt/files)"
    required: true
    default: null
    aliases: []
  src:
    description:
      - device to be mounted on I(name).
    required: false
    default: null
  fstype:
    description:
      - file-system type
    required: true
    default: null
  opts:
    description:
      - mount options (see fstab(8))
    required: false
    default: null
  dump:
    description:
      - dump (see fstab(8))
    required: false
    default: null
  passno:
    description:
      - passno (see fstab(8))
    required: false
    default: null
  state:
    description:
      - If C(mounted) or C(unmounted), the device will be actively mounted or unmounted
        as well as just configured in I(fstab). C(absent) and C(present) only deal with
        I(fstab). C(only_if_present) and C(only_if_mounted) only deal if the line already exists in I(fstab).
    required: true
    choices: [ "present", "absent", "mounted", "unmounted", "only_if_present", "only_if_mounted" ]
    default: null
examples:
   - code: "mount: name=/mnt/dvd src=/dev/sr0 fstype=iso9660 opts=ro state=present"
     description: "Mount DVD read-only"
notes: []
requirements: []
author: Seth Vidal
'''

def write_fstab(lines, dest):

    fs_w = open(dest, 'w')
    for l in lines:
        fs_w.write(l)

    fs_w.flush()
    fs_w.close()

def read_fstab(args):
    """ read mount points in fstab """

    fstab = []
    exists = False
    for line in open(args['fstab'], 'r').readlines():
        if line.strip().startswith('#'):
            fstab.append(line)
            continue
        if len(line.split()) != 6:
            # not sure what this is or why it is here
            # but it is not our fault so leave it be
            fstab.append(line)
            continue
        ld = {}
        ld['src'], ld['name'], ld['fstype'], ld['opts'], ld['dump'], ld['passno']  = line.split()
        if ld['name'] == args['name']:
           # Fill 'src' arg if it is empty
           if args['src'] is None:
               args['src'] = ld['src']
           # And yes, a line matches the name pattern
           exists = True
           fstab.append(line)
        else:
           fstab.append(line)
    
    return (args, exists, fstab)

def set_mount(**kwargs):
    """ set/change a mount point location in fstab """

    # kwargs: name, src, fstype, opts, dump, passno, state, fstab=/etc/fstab
    args = dict(
        opts   = 'defaults',
        dump   = '0',
        passno = '0',
        fstab  = '/etc/fstab'
    )
    args.update(kwargs)

    new_line = '%(src)s %(name)s %(fstype)s %(opts)s %(dump)s %(passno)s\n'

    changed = False
    args, exists, current = read_fstab(args)
    to_write = []

    if not exists:
        if args['src'] is None and args['state'] not in ['only_if_mounted', 'only_if_present']:
            msg="Error: no 'src' provided but '%s' not found in fstab. Can't add mount point without all required parameters." % (args['name'])
            return 1, msg
        if args['state'] in ['only_if_mounted', 'only_if_present']: 
            msg="Error: %s not found in fstab." % (args['name'])
            return 1, msg

    # Not found and line valid, write new line and final point.
        for line in current:
            to_write.append(line)
        to_write.append(new_line % args)
        changed = True
    else:
        for line in current:
            if len(line.split()) != 6:
                to_write.append(line)
                continue
            ld = {}
            ld['src'], ld['name'], ld['fstype'], ld['opts'], ld['dump'], ld['passno']  = line.split()
            if ld['name'] != args['name']:
                to_write.append(line)
            else:
                for t in ('src', 'fstype','opts', 'dump', 'passno'):
                    if ld[t] != args[t]:
                        changed = True
                        ld[t] = args[t]
                if changed:
                    to_write.append(new_line % ld)

    if changed:
        write_fstab(to_write, args['fstab'])

    return (args['name'], changed)


def unset_mount(**kwargs):
    """ remove a mount point from fstab """

    # kwargs: name, src, fstype, opts, dump, passno, state, fstab=/etc/fstab
    args = dict(
        opts   = 'default',
        dump   = '0',
        passno = '0',
        fstab  = '/etc/fstab'
    )
    args.update(kwargs)

    changed = False
    args, exists, current = read_fstab(args)
    to_write = []

    # If not found, no need to go further. Otherwise:
    if exists:
        for line in current:
            if len(line.split()) != 6:
                to_write.append(line)
                continue
            ld = {}
            ld['src'], ld['name'], ld['fstype'], ld['opts'], ld['dump'], ld['passno']  = line.split()

            if ld['name'] != args['name']:
                to_write.append(line)
                continue

            # name matches, src too ?
            if ld['src'] != args['src']:
                continue

            # if we got here we found a match - continue and mark changed
            changed = True

    if changed:
        write_fstab(to_write, args['fstab'])

    return (args['name'], changed)


def mount(module, **kwargs):
    """ mount up a path or remount if needed """

    name = kwargs['name']
    if os.path.ismount(name):
        cmd = [ '/bin/mount', '-o', 'remount', name ]
    else:
        cmd = [ '/bin/mount', name ]

    rc, out, err = module.run_command(cmd)
    if rc == 0:
        return 0, ''
    else:
        return rc, out+err

def umount(module, **kwargs):
    """ unmount a path """

    name = kwargs['name']
    cmd = ['/bin/umount', name]

    rc, out, err = module.run_command(cmd)
    if rc == 0:
        return 0, ''
    else:
        return rc, out+err

def main():

    module = AnsibleModule(
        argument_spec = dict(
            state  = dict(required=True, choices=['present', 'absent', 'mounted', 'unmounted', 'only_if_present', 'only_if_mounted']),
            name   = dict(required=True),
            opts   = dict(default=None),
            passno = dict(default=None),
            dump   = dict(default=None),
            src    = dict(default=None),
            fstype = dict(required=True),
            fstab  = dict(default=None),
            delmp  = dict(default=None)
        )
    )

    changed = False
    exists = False
    rc = 0
    args = {
        'name': module.params['name'],
        'fstype': module.params['fstype'],
        'state': module.params['state']
    }
    if module.params['src'] is not None:
        args['src'] = module.params['src']
    else:
        args['src'] = None
    if module.params['passno'] is not None:
        args['passno'] = module.params['passno']
    if module.params['opts'] is not None:
        args['opts'] = module.params['opts']
    if module.params['dump'] is not None:
        args['dump'] = module.params['dump']
    if module.params['fstab'] is not None:
        args['fstab'] = module.params['fstab']

    # absent == remove from fstab and unmounted
    # unmounted == do not change fstab state, but unmount
    # present == add to fstab, do not change mount state
    # mounted == add to fstab if not there and make sure it is mounted, if it has changed in fstab then remount it
    # only_if_present == modify line in fstab, only if present, do not change mount state
    # only_if_mounted == modify line in fstab, only if present, if it has changed then remount it.

    state = module.params['state']
    name  = module.params['name']
    if state == 'absent':
        name, changed = unset_mount(**args)
        if changed:
            if os.path.ismount(name):
                res,msg  = umount(module, **args)
                if res:
                    module.fail_json(msg="Error unmounting %s: %s" % (name, msg))

            if os.path.exists(name) and module.params['delmp'] is not None:
                try:
                    os.rmdir(name)
                except (OSError, IOError), e:
                    module.fail_json(msg="Error rmdir %s: %s" % (name, str(e)))

        module.exit_json(changed=changed, **args)

    if state == 'unmounted':
        if os.path.ismount(name):
            res,msg  = umount(module, **args)
            if res:
                module.fail_json(msg="Error unmounting %s: %s" % (name, msg))
            changed = True

        module.exit_json(changed=changed, **args)

    if state in ['mounted', 'present', 'only_if_mounted', 'only_if_present']:
        name, changed = set_mount(**args)
        if name == 1:
            module.fail_json(msg=changed)
        if state == 'mounted':
            if not os.path.exists(name):
                try:
                    os.makedirs(name)
                except (OSError, IOError), e:
                    module.fail_json(msg="Error making dir %s: %s" % (name, str(e)))

            res = 0
            if os.path.ismount(name):
                if changed:
                    res,msg = mount(module, **args)
            else:
                changed = True
                res,msg = mount(module, **args)

            if res:
                module.fail_json(msg="Error mounting %s: %s" % (name, msg))


        module.exit_json(changed=changed, **args)

    module.fail_json(msg='Unexpected position reached')
    sys.exit(0)

# this is magic, see lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>
main()
