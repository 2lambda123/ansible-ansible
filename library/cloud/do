#!/usr/bin/python
# -*- coding: utf-8 -*-

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
DOCUMENTATION = '''
---
module: do
short_description: Create/delete an instance in DigitalOcean
description:
     - Create/delete an instance in DigitalOcean and optionally waits for it to be 'running'.
version_added: "0.1"
options:
  state:
    description:
     - Indicate desired state of the droplet.
    required: true
    choices: ['present', 'active', 'absent', 'deleted']
  client_id: description:
     - Digital Ocean client id.
  api_key:
    description:
     - Digital Ocean api key.
  id:
    description:
     - Numeric, the droplet id you want to operate on.
  name:
    description:
     - String, this is the name of the droplet - must be formatted by hostname rules.
  size_id:
    description:
     - Numeric, this is the id of the size you would like the droplet created at.
  image_id:
    description:
     - Numeric, this is the id of the image you would like the droplet created with.
  region_id:
    description:
     - Numeric, this is the id of the region you would like your server in IE: US/Amsterdam.
  ssh_key_ids:
    description:
     - Optional, comma separated list of ssh_key_ids that you would like to be added to the server
  wait:
    description: 
     - Wait for the droplet to be in state 'running' before returning.
    default: "yes"
    choices: [ "yes", "no" ]
  wait_timeout:
    description:
     - How long before wait gives up, in seconds.
    default: 360

notes:
  - Two environment variables can be used, DO_CLIENT_ID and DO_API_KEY.
'''


EXAMPLES = '''
# a playbook task line:
tasks:
  - do: state=active client_id=XXX api_key=XXX id=33

# /usr/bin/ansible invocations
ansible -i host -m do -a "state=active client_id=XXX api_key=XXX id=3"
'''

import sys
import os
import time

try:
    from dopy.client import Client
except ImportError as e:
    print "failed=True msg='dopy required for this module'"
    sys.exit(1)

class DoProxy(object):

    def __init__(self, module):
        self.params = module.params
        self.fail_json = module.fail_json
        self.exit_json = module.exit_json
        # setup the auth
        try:
            # params['client_id'] will be None even if client_id is not passed in
            client_id = self.params['client_id'] or os.environ['DO_CLIENT_ID']
            api_key = self.params['api_key'] or os.environ['DO_API_KEY']
        except KeyError, e:
            self.fail_json(msg='Unable to load %s' % e.message)
        self.client = Client(client_id, api_key)

    def process(self):
        """
        Returns a dict of the executed result.
        Or causing the whole program to exit by using fail_json.
        """
        command = self.getkeyordie('command')
        state = self.getkeyordie('state')
        if command == 'droplet':
            if state in ('active', 'present'):
                if self.params['id'] is not None:
                    droplet = self.find_droplet()
                    if droplet:  # already exist
                        id = droplet['id']
                if 'id' not in locals():
                    droplet = self.create_droplet()
                    id = droplet['id']
                return {'changed': True, 'droplet': self.ensure_powered_on(id)}

            elif state in ('absent', 'deleted'):
                droplet = self.find_droplet()
                if droplet:
                    return {'changed': True, 'event_id': self.destroy_droplet()}
                return {'changed': False, 'msg': 'The droplet is not found.'}
        elif command == 'SSH':
            if state in ('active', 'present'):
                return self.add_ssh_key(self.getkeyordie('key_name'), self.getkeyordie('ssh_pub_key'))


    def getkeyordie(self, k):
        v = self.params[k]
        if v is None:
            self.fail_json(msg='Unable to load %s' % k)
        return v

    def create_droplet(self):
        """
        Returns the created droplet info or exit the whole program.
        """
        result = self.client.create(
                    name = self.getkeyordie('name'),
                    size_id = self.getkeyordie('size_id'),
                    image_id = self.getkeyordie('image_id'),
                    region_id = self.getkeyordie('region_id'),
                    ssh_key_ids = self.params.get('ssh_key_ids'),
                )
        if result.get('status') == 'OK':
            return result['droplet']
        self.fail_json(msg=result['error_message'])

    def show_droplet_info(self, id=None, times=5):
        id = id or self.getkeyordie('id')
        result = self.client.show(id)
        if result.get('status') == 'OK':
            if not result['droplet']['ip_address'] and times>0:
                time.sleep(2)
                return self.show_droplet_info(id, times-1)
            return result['droplet']
        self.fail_json(msg=result['error_message'])

    def destroy_droplet(self, id=None):
        id = id or self.getkeyordie('id')
        result = self.client.destroy(id)
        if result.get('status') == 'OK':
            return result['event_id']
        self.fail_json(msg=result['error_message'])

    def find_droplet(self, id=None):
        id = id or self.getkeyordie('id')
        result = self.client.show_active()
        for droplet in result['droplets']:
            if droplet['id'] == id:
                return droplet
        return False

    def ensure_powered_on(self, id=None):
        id = id or self.getkeyordie('id')
        is_powered_on = lambda d: d.get('status') == 'active'

        def wait_for_running():
            end_time = time.time()+int(self.params['wait_timeout'])
            while time.time()<end_time:
                time.sleep(min(20, end_time-time.time()))
                droplet = self.show_droplet_info(id)
                if is_powered_on(droplet):
                    return droplet
            self.fail_json(msg=
                    'wait for droplet running timeout on id:%s' % id, id=id)

        droplet = self.show_droplet_info(id)
        if is_powered_on(droplet):
            return droplet
        should_wait = self.params['wait']
        if droplet['status'] == 'new':  # just created
            if should_wait:
                return wait_for_running()
            return droplet
        elif droplet['status'] == 'off':  # powered off
            result = self.client.power_on(id)
            if result.get('status') == 'OK':
                if should_wait:
                    return wait_for_running()
                return self.show_droplet_info()
            self.fail_json(msg=result['error_message'])

    def add_ssh_key(self, name, key_pub):
        result = self.client.add_ssh_key(name, key_pub)
        if result.get('status') == 'OK':
            return result['ssh_key']
        self.fail_json(msg=result['error_message'])


def main():
    module = AnsibleModule(
        argument_spec = dict(
            command = dict(required=True, choices=['droplet', 'SSH']),
            state = dict(required=True, choices=['active', 'present', 'absent', 'deleted']),
            client_id = dict(aliases=['CLIENT_ID'], no_log=True),
            api_key = dict(aliases=['API_KEY'], no_log=True),
            name = dict(),
            size_id = dict(),
            image_id = dict(),
            region_id = dict(),
            ssh_key_ids = dict(default=''),
            id = dict(aliases=['droplet_id'], type='int'),
            key_name = dict(),
            ssh_pub_key = dict(),
            wait = dict(type='bool', choices=BOOLEANS, default='yes'),
            wait_timeout = dict(default=360),
        ),
        required_together = (
            ['name', 'size_id', 'image_id', 'region_id'],
        )
    )

    try:
        result = DoProxy(module).process()
    except Exception as e:
        module.fail_json(msg=str(e))
    module.exit_json(**result)

# this is magic, see lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>

main()
