#!/usr/bin/python
# -*- coding: utf-8 -*-

# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
DOCUMENTATION = '''
---
module: do
short_description: Create/delete an instance in DigitalOcean
description:
     - Create/delete an instance in DigitalOcean and optionally waits for it to be 'running'.
version_added: "0.1"
options:
  state:
    description:
     - Indicate desired state of the resource.
    required: true
    choices: ['present', 'active', 'absent', 'deleted']
  client_id: description:
     - Your client id.
    required: true
  api_key:
    description:
     - Your api key.
    required: true
  name:
    description:
     - String, this is the name of the droplet - must be formatted by hostname rules.
  size_id:
    description:
     - Numeric, this is the id of the size you would like the droplet created at.
  image_id:
    description:
     - Numeric, this is the id of the image you would like the droplet created with.
  region_id:
    description:
     - Numeric, this is the id of the region you would like your server in IE: US/Amsterdam.
  virtio:
    description:
     - Optional, default: true, this toggles whether to enable or disable virtio during creation.
    choices: [ "true", "false" ]
  ssh_key_ids:
    description:
     - Optional, comma separated list of ssh_key_ids that you would like to be added to the server
  wait:
    description: 
     - Wait for the instance to be in state 'running' before returning, this is the recommended way since currently we can do nothing on event_id.
    default: "yes"
    choices: [ "yes", "no" ]
  wait_timeout:
    description:
     - How long before wait gives up, in seconds.
    default: 300

notes:
  - Two environment variables can be used, CLIENT_ID and API_KEY.
'''


EXAMPLES = '''
# a playbook task line:
tasks:
  - do: start=active client_id=XXX api_key=XXX id=33

# /usr/bin/ansible invocations
ansible -i host -m do -a "start=active client_id=XXX api_key=XXX id=3"
'''

import sys
import os
import time

try:
    from dop.client import Client
except ImportError:
    print "failed=True msg='python module dop unavailable'"
    sys.exit(1)

# TODO, fix the dop library
AuthError = Exception

class DopProxy(object):

    def __init__(self, module):
        self.params = module.params
        self.fail_json = module.fail_json
        self.exit_json = module.exit_json
        self.types = {k: v.get('type') for k, v in module.argument_spec.iteritems()}
        # setup the auth
        try:
            # params['client_id'] will be None even if client_id is not passed in
            client_id = self.params['client_id'] or os.environ['CLIENT_ID']
            api_key = self.params['api_key'] or os.environ['API_KEY']
        except KeyError, e:
            self.fail_json(msg='Unable to load %s' % e.message.lower())
        self.client = Client(client_id, api_key, True)

    def handle(self):
        state = self.getkeyordie('state')
        try:
            if state == 'present':
                if self.find_droplet():
                    return {'changed': False, 'droplet': self.droplet.to_json()}
                droplet = self.create_droplet()
                return {'changed': True, 'droplet': droplet.to_json()}

            elif state == 'active':
                if self.find_active_droplet():
                    return {'changed': False, 'droplet': self.droplet.to_json()}
                elif self.find_droplet():  # which means powered off
                    if self.power_on_droplet():
                        return {'changed': True, 'droplet': self.droplet.to_json()}
                    elif not self.params['wait']:
                        return {'changed': True, 'event_id': self.event_id}
                    self.fail_json(msg='Timeout waiting on %s' % self.getkeyordie('id'))
                else:  # not exist
                    self.fail_json(msg='Server %s not found in your account' % self.getkeyordie('id'))

            elif state == 'deleted':
                if self.destroy_droplet():
                    return {'changed': True, 'event_id': self.event_id}
                raise AuthError('XXX')

            elif state == 'absent':
                if self.shutdown_droplet():
                    return {'changed': True, 'event_id': self.event_id}
                raise AuthError('XXX')

        except AuthError, e:
            self.fail_json(msg=e.message)
            

    def getkeyordie(self, k):
        v = self.params[k]
        if v is None:
            self.fail_json(msg='Unable to load %s' % k)
        return v

    def create_droplet(self):
        try:
            return self.client.create_droplet(
                    name = self.getkeyordie('name'),
                    size_id = self.getkeyordie('size_id'),
                    image_id = self.getkeyordie('image_id'),
                    region_id = self.getkeyordie('region_id'),
                    virtio = self.params['virtio'],
                    ssh_key_ids = self.params.get('ssh_key_ids', '').split(','),
                    )
        except AttributeError, e:
            self.module.fail_json(msg=str(e))

    def find_droplet(self):
        """Return True if find a droplet by the given id, which is stored in
        self.droplet, else return False"""
        # id is an aliase of id, here for readability.
        id = self.getkeyordie('id')
        try:
            self.droplet = self.client.show_droplet(id)
            return True
        except:
            return False

    def find_active_droplet(self):
        id = self.getkeyordie('id')
        droplets = self.client.show_active_droplets()
        for d in droplets:
            if id == d.id:
                self.droplet = d
                return True
        return False

    def power_on_droplet(self):
        id = self.getkeyordie('id')
        self.event_id = self.client.power_on_droplet(id)
        if self.params['wait']:
            end_time = time.time()+self.params['wait_timeout']
            while time.time()<end_time:
                if self.find_active_droplet():
                    return True
                time.sleep(min(5, end_time-time.time()))
            return False
        return None

    def destroy_droplet(self):
        id = self.getkeyordie('id')
        try:
            self.event_id = self.client.destroy_droplet(id)
            return True
        except:
            return False

    def shutdown_droplet(self):
        id = self.getkeyordie('id')
        try:
            self.event_id = self.client.shutdown_droplet(id)
            return True
        except:
            return False

def main():
    module = AnsibleModule(
        argument_spec = dict(
            state = dict(required=True, choices=['active', 'present', 'deleted', 'absent']),
            client_id = dict(aliases=['CLIENT_ID'], no_log=True),
            api_key = dict(aliases=['API_KEY'], no_log=True),
            name = dict(),
            size_id = dict(),
            image_id = dict(),
            region_id = dict(),
            virtio = dict(choices=BOOLEANS, default=True),
            ssh_key_ids = dict(default=''),
            id = dict(aliases=['droplet_id']),
            wait = dict(choices=BOOLEANS, default='yes'),
            wait_timeout = dict(default=300),
        ),
        required_together = (
            # use list here because str-format treats tuple specially
            ['name', 'size_id', 'image_id', 'region_id'],
        )
    )

    proxy = DopProxy(module)
    result = proxy.handle()
    module.exit_json(**result)

# this is magic, see lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>

main()
