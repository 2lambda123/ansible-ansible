#!/usr/bin/python
# -*- coding: utf-8 -*-


DOCUMENTATION = '''
---
module: ec2_group
version_added: "1.3"
short_description: maintain an ec2 VPC security group.
description:
    - maintains ec2 security groups. This module has a dependency on python-boto >= 2.5
options:
  name:
    description:
      - Name of the security group.
    required: true
  description:
    description:
      - Description of the security group.
    required: true
  vpc_id:
    description:
      - ID of the VPC to create the group in.
    required: false
  rules:
    description:
      - List of firewall rules to enforce in this group (see example).
    required: true
  rules_egress:
    version_added: "1.8"
    description:
      - List of firewall egress rules to enforce in this group(see example).
    required: false
  region:
    description:
      - the EC2 region to use
    required: false
    default: null
    aliases: []
  ec2_url:
    description:
      - Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints)
    required: false
    default: null
    aliases: []
  ec2_secret_key:
    description:
      - EC2 secret key
    required: false
    default: null
    aliases: ['aws_secret_key']
  ec2_access_key:
    description:
      - EC2 access key
    required: false
    default: null
    aliases: ['aws_access_key']
  state:
    version_added: "1.4"
    description:
      - create or delete security group
    required: false
    default: 'present'
    aliases: []
  validate_certs:
    description:
      - When set to "no", SSL certificates will not be validated for boto versions >= 2.6.0.
    required: false
    default: "yes"
    choices: ["yes", "no"]
    aliases: []
    version_added: "1.5"
  profile:
    description:
      - uses a boto profile. Only works with boto >= 2.24.0
    required: false
    default: null
    aliases: []
    version_added: "1.6"
  security_token:
    description:
      - security token to authenticate against AWS
    required: false
    default: null
    aliases: []
    version_added: "1.6"

requirements: [ "boto" ]
'''

EXAMPLES = '''
- name: example ec2 group
  local_action:
    module: ec2_group
    name: example
    description: an example EC2 group
    vpc_id: 12345
    region: eu-west-1a
    ec2_secret_key: SECRET
    ec2_access_key: ACCESS
    rules:
      - proto: tcp
        from_port: 80
        to_port: 80
        cidr_ip: 0.0.0.0/0
      - proto: tcp
        from_port: 22
        to_port: 22
        cidr_ip: 10.0.0.0/8
      - proto: udp
        from_port: 10050
        to_port: 10050
        cidr_ip: 10.0.0.0/8
      - proto: udp
        from_port: 10051
        to_port: 10051
        group_id: sg-12345678
      - proto: all
        # the containing group name may be specified here
        group_name: example
    rules_egress:
      - proto: tcp
        from_port: 80
        to_port: 80
        cidr_ip: 0.0.0.0/0
      - proto: tcp
        from_port: 443
        to_port: 443
        cidr_ip: 0.0.0.0/0
      - proto: all
        # the containing group name may be specified here
        group_name: example    
'''

try:
    import boto.ec2
except ImportError:
    print "failed=True msg='boto required for this module'"
    sys.exit(1)

from ansible.module_utils.basic import *
from ansible.module_utils.ec2 import *

class Ec2Group:
    def addRulesToLookup(self, rules, prefix, dict):
        for rule in rules:
            for grant in rule.grants:
                ruleId = "%s-%s-%s-%s-%s-%s" % (prefix, rule.ip_protocol, rule.from_port, rule.to_port,
                                            grant.group_id, grant.cidr_ip)
                dict[ruleId] = rule

    def checkRules(self, rules, groupRules, egress):
        for rule in rules:
            group_id = None
            group_name = None
            ip = None
            if 'group_id' in rule and 'cidr_ip' in rule:
                self.module.fail_json(msg="Specify group_id OR cidr_ip, not both")
            elif 'group_name' in rule and 'cidr_ip' in rule:
                self.module.fail_json(msg="Specify group_name OR cidr_ip, not both")
            elif 'group_id' in rule and 'group_name' in rule:
                self.module.fail_json(msg="Specify group_id OR group_name, not both")
            elif 'group_id' in rule:
                group_id = rule['group_id']
            elif 'group_name' in rule:
                group_name = rule['group_name']
                if group_name in self.groups:
                    group_id = self.groups[group_name].id
                elif group_name == name:
                    group_id = self.group.id
                    groups[group_id] = self.group
                    groups[group_name] = self.group
            elif 'cidr_ip' in rule:
                ip = rule['cidr_ip']

            if rule['proto'] == 'all':
                rule['proto'] = -1
                rule['from_port'] = None
                rule['to_port'] = None
            # If rule already exists, don't later delete it
            ruleId = ""
            if egress:
                ruleId = "%s-%s-%s-%s-%s-%s" % ('out', rule['proto'], rule['from_port'], rule['to_port'], group_id, ip)
            else:
                ruleId = "%s-%s-%s-%s-%s-%s" % ('in', rule['proto'], rule['from_port'], rule['to_port'], group_id, ip)
            if ruleId in groupRules:
                del groupRules[ruleId]
            # Otherwise, add new rule
            else:
                grantGroup = None
                if group_id:
                    grantGroup = self.groups[group_id]

                if not self.module.check_mode:
                    if egress:
                        if grantGroup:
                            self.ec2.authorize_security_group_egress(group_id=self.group.id,ip_protocol=rule['proto'],from_port=rule['from_port'],to_port=rule['to_port'],src_group_id=grantGroup, dry_run=False)
                        else:
                            self.ec2.authorize_security_group_egress(group_id=self.group.id,ip_protocol=rule['proto'],from_port=rule['from_port'],to_port=rule['to_port'],cidr_ip=ip, dry_run=False)
                    else:
                        self.group.authorize(rule['proto'], rule['from_port'], rule['to_port'], ip, grantGroup)
                self.changed = True

         # Finally, remove anything left in the groupRules -- these will be defunct rules
        for rule in groupRules.itervalues():
            for grant in rule.grants:
                grantGroup = None
                if grant.group_id:
                    grantGroup = self.groups[grant.group_id]
                if not self.module.check_mode:
                    if egress:
                        if grantGroup:
                            self.ec2.revoke_security_group_egress(group_id=self.group.id,ip_protocol=rule.ip_protocol,from_port=rule.from_port,to_port=rule.to_port,src_group_id=grantGroup)
                        else:
                            self.ec2.revoke_security_group_egress(group_id=self.group.id,ip_protocol=rule.ip_protocol,from_port=rule.from_port,to_port=rule.to_port,cidr_ip=grant.cidr_ip)
                    else:
                        self.group.revoke(rule.ip_protocol, rule.from_port, rule.to_port, grant.cidr_ip, grantGroup)
                self.changed = True       

    def __init__(self):
        argument_spec = ec2_argument_spec()
        argument_spec.update(dict(
                name=dict(required=True),
                description=dict(required=True),
                vpc_id=dict(),
                rules=dict(),
                rules_egress=dict(),
                state = dict(default='present', choices=['present', 'absent']),
            )
        )
        self.module = AnsibleModule(
            argument_spec=argument_spec,
            supports_check_mode=True,
        )

        name = self.module.params['name']
        description = self.module.params['description']
        vpc_id = self.module.params['vpc_id']
        rules = self.module.params['rules']
        state = self.module.params.get('state')
        rulesEgress = self.module.params['rules_egress']
        self.changed = False

        self.ec2 = ec2_connect(self.module)

        # find the group if present
        self.group = None
        self.groups = {}
        for curGroup in self.ec2.get_all_security_groups():
            self.groups[curGroup.id] = curGroup
            self.groups[curGroup.name] = curGroup

            if curGroup.name == name and (vpc_id is None or curGroup.vpc_id == vpc_id):
                self.group = curGroup

        # Ensure requested group is absent
        if state == 'absent':
            if self.group:
                '''found a match, delete it'''
                try:
                    self.group.delete()
                except Exception, e:
                    self.module.fail_json(msg="Unable to delete security group '%s' - %s" % (group, e))
                else:
                    self.group = None
                    self.changed = True
            else:
                '''no match found, no changes required'''

        # Ensure requested group is present
        elif state == 'present':
            if self.group:
                '''existing group found'''
                # check the group parameters are correct
                group_in_use = False
                rs = self.ec2.get_all_instances()
                for r in rs:
                    for i in r.instances:
                        group_in_use |= reduce(lambda x, y: x | (y.name == 'public-ssh'), i.groups, False)

                if self.group.description != description:
                    if group_in_use:
                        self.module.fail_json(msg="Group description does not match, but it is in use so cannot be changed.")

            # if the group doesn't exist, create it now
            else:
                '''no match found, create it'''
                if not self.module.check_mode:
                    self.group = self.ec2.create_security_group(name, description, vpc_id=vpc_id)
                    for curGroup in self.ec2.get_all_security_groups():
                        self.groups[curGroup.id] = curGroup
                        self.groups[curGroup.name] = curGroup
                        if curGroup.name == name and (vpc_id is None or curGroup.vpc_id == vpc_id):
                            self.group = curGroup
                self.changed = True
        else:
            self.module.fail_json(msg="Unsupported state requested: %s" % state)

        # create a lookup for all existing rules on the group
        if self.group:
            groupRules = {}
            groupRulesEgress = {}
            self.addRulesToLookup(self.group.rules, 'in', groupRules)
            self.addRulesToLookup(self.group.rules_egress, 'out', groupRulesEgress)
            # Now, go through all provided rules and ensure they are there.
            if rules:
               self.checkRules(rules,groupRules,False)
            if rulesEgress:
               self.checkRules(rulesEgress,groupRulesEgress,True)
        if self.group:
            self.module.exit_json(changed=self.changed, group_id=self.group.id)
        else:
            self.module.exit_json(changed=self.changed, group_id=None)


def main():
    Ec2Group()

main()