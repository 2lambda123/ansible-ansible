#!/usr/bin/python
#coding: utf-8 -*-

# (c) 2013, Benno Joy <benno@ansible.com>
# (c) 2013, John Dewey <john@dewey.ws>
#
# This module is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this software.  If not, see <http://www.gnu.org/licenses/>.

try:
    from novaclient.v1_1 import client as nova_client
    from novaclient import exceptions
    import time
except ImportError:
    print("failed=True msg='novaclient is required for this module'")

from ansible.module_utils.basic import *

DOCUMENTATION = '''
---
module: nova_compute
version_added: "1.2"
short_description: Create/Delete VMs from OpenStack
description:
   - Create or Remove virtual machines from Openstack.
options:
   login_username:
     description:
        - login username to authenticate to keystone
     required: true
     default: admin
   login_password:
     description:
        - Password of login user
     required: true
     default: 'yes'
   login_tenant_name:
     description:
        - The tenant name of the login user
     required: true
     default: 'yes'
   auth_url:
     description:
        - The keystone url for authentication
     required: false
     default: 'http://127.0.0.1:35357/v2.0/'
   region_name:
     description:
        - Name of the region
     required: false
     default: None
   state:
     description:
        - Indicate desired state of the resource
     choices: ['present', 'absent']
     default: present
   name:
     description:
        - Name that has to be given to the instance
     required: true
     default: None
   source_type:
     description:
        - One of the choises:
          - image
          - volume
          - image_volume (creates volume)
          - volume_snapshot (creates volume)
     default: image
     choices: ['image','image_volume','volume','volume_snapshot']
     version_added: "1.6"
   source_id:
     description:
        - The id of the image or image snapshot that has to be cloned
        - Volume ID to boot from.
        - Sapshot ID to boot from (will create a volume).
     required: true
     default: None
     aliases: [ image_id ]
     version_added: "1.6"
   volume_size:
     description:
        - Size of the volume to be created (source type: image_volume, volume_snapshot)
     required: yes, when source_type is image_volume or volume_snapshot
     version_added: "1.6"
   flavor_id:
     description:
        - The id of the flavor in which the new VM has to be created
     required: false
     default: 1
   key_name:
     description:
        - The key pair name to be used when creating a VM
     required: false
     default: None
   availability_zone:
     description:
       - The availability zone for server placement.
     required: false
     version_added: "1.6"
   security_groups:
     description:
        - Comma separated list of security group names.
     required: false
     default: None
   netids:
     description:
       - List of network ids, will override nics
     required: false
     default: None
     version_added: "1.6"
   nics:
     description:
        - A list of network id's to which the VM's interface should be attached
     required: false
     default: None
   delete_on_termination:
     description: A boolean to indicate whether the volume should be deleted when the instance is terminated.
     default: false
     version_added: "1.6"
   meta:
     description:
        - A list of key value pairs that should be provided as a metadata to the new VM
     required: false
     default: None
   wait:
     description:
        - If the module should wait for the VM to be created.
     required: false
     default: 'yes'
   wait_for:
     description:
        - The amount of time the module should wait for the VM to get into active state
     required: false
     default: 180
   user_data:
     description:
        - Opaque blob of data which is made available to the instance
     required: false
     default: None
requirements: ["novaclient"]
'''

EXAMPLES = '''
# Creates a new VM and attaches to a network and passes metadata to the instance
- nova_compute:
    state: present
    login_username: admin
    login_password: admin
    login_tenant_name: demo
    name: vm1
    source_type: image
    image_id: 4f905f38-e52a-43d2-b6ec-754a13ffb529
    key_name: ansible_key
    wait_for: 200
    flavor_id: 4
    netids: 34605f38-e52a-25d2-b6ec-754a13ffb723
    meta:
        hostname: vm1
        group: master

- name: create vm from image (creates volume)
  nova_compute:
    name: "{{ item }}"
    state: present
    source_type: image_volume
    source_id: ea5d1a42-c99e-41f3-997f-6aa9a3795229
    volume_size: 20
    key_name: default
    wait_for: 300
    flavor_id: 2
    netids:
      - 29efdeb9-a20b-4f2e-902b-2153739b3f52
    delete_on_termination: yes
    meta:
      hostname: "{{ item }}"
      group: replset1
    login_username: "{{ username }}"
    login_password: "{{ password }}"
    login_tenant_name: "{{ tenant }}"
    auth_url: "{{ auth_url }}"
  with_items:
    - rs1_1
    - rs1_2
    - rs1_3
'''

def _find_server(module, nova):
    """Find server by name."""
    try:
        servers = nova.servers.list(True, {'name': module.params['name']})
        if servers:
            # the {'name': module.params['name']} will also return servers
            # with names that partially match the server name, so we have to
            # strictly filter here
            servers = [x for x in servers if x.name == module.params['name']]
            if servers:
                return servers[0]
            else:
                return None
    except Exception as e:
        module.fail_json(msg = "Error in getting the server list: %s" % e.message)

def _return_server_and_exit(module, server, changed):
    """Prepare and return server info."""
    private = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if 'OS-EXT-IPS:type' in x and x['OS-EXT-IPS:type'] == 'fixed']
    public  = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if 'OS-EXT-IPS:type' in x and x['OS-EXT-IPS:type'] == 'floating']
    module.exit_json(changed = changed, id = server.id, public_ip = ''.join(public), private_ip = ''.join(private), info = server._info)

def _delete_server(module, nova, server):
    """Delete vm by server id."""
    try:
        nova.servers.delete(server)
    except Exception as e:
        module.fail_json( msg = "Error in deleting vm: %s" % e.message)
    if module.params['wait']:
        expire = time.time() + int(module.params['wait_for'])
        while time.time() < expire:
            try:
                nova.servers.get(server.id)
            except exceptions.NotFound:
                module.exit_json(changed = True, result = "deleted")
            time.sleep(2)
        module.fail_json(msg = "Timed out waiting for server to get deleted, please check manually")
    else:
        module.exit_json(changed = True, result = "deleted")


def _create_server(module, nova):
    """Create new vm."""
    image_id = ''
    dev_mapping_2 = None
    source_type = module.params['source_type']
    netids =  module.params['netids']

    if source_type == 'image':
        image_id = module.params['source_id']
    elif source_type == 'image_volume':
        dev_mapping_2 = [
            {
                "uuid": module.params['source_id'],
                "source_type": "image",
                "destination_type": "volume",
                "boot_index": "0",
                "volume_size": module.params['volume_size'],
                'delete_on_termination': module.params['delete_on_termination']
            }
        ]
    elif source_type == 'volume':
        dev_mapping_2 = [
            {
                "uuid": module.params['source_id'],
                "source_type": "volume",
                "destination_type": "volume",
                "boot_index": "0",
                "volume_size": module.params['volume_size'],
                'delete_on_termination': module.params['delete_on_termination']
            }
        ]
    elif source_type == 'volume_snapshot':
        dev_mapping_2 = [
            {
                "uuid": module.params['source_id'],
                "source_type": "snapshot",
                "destination_type": "volume",
                "boot_index": "0",
                "volume_size": module.params['volume_size'],
                'delete_on_termination': module.params['delete_on_termination']
            }
        ]
    if netids:
        nics = [{"net-id": netid, "v4-fixed-ip": ""} for netid in netids]
    else:
        nics = module.params['nics']
    try:
        server = nova.servers.create(
            module.params['name'],
            image_id,
            module.params['flavor_id'],
            security_groups=module.params['security_groups'],
            key_name=module.params['key_name'],
            availability_zone=module.params['availability_zone'],
            block_device_mapping_v2 = dev_mapping_2,
            nics=nics,
            meta=module.params['meta'],
            userdata=module.params['user_data'],
        )
        server = nova.servers.get(server.id)
    except Exception as e:
        module.fail_json( msg = "Error in creating instance: %s " % e.message)
    if module.params['wait']:
        expire = time.time() + int(module.params['wait_for'])
        while time.time() < expire:
            try:
                server = nova.servers.get(server.id)
            except Exception as e:
                module.fail_json( msg = "Error in getting info from instance: %s " % e.message)
            if server.status == 'ACTIVE':
                _return_server_and_exit(module, server, changed = True)
            if server.status == 'ERROR':
                module.fail_json(msg = "Error in creating the server, please check logs")
            time.sleep(2)
        module.fail_json(msg = "Timeout waiting for the server to come up. Please check manually.")
    if server.status == 'ACTIVE':
        _return_server_and_exit(module, server, changed = True)
    elif server.status == 'ERROR':
        module.fail_json(msg = "Error in creating the server. Please check manually.")
    else:
        module.exit_json(changed = True, id = server.id, status = server.status, info = server._info)


def main():
    module = AnsibleModule(
        argument_spec = dict(
            login_username          = dict(default='admin'),
            login_password          = dict(required=True),
            login_tenant_name       = dict(required='True'),
            auth_url                = dict(default='http://127.0.0.1:35357/v2.0/'),
            region_name             = dict(default=None),
            name                    = dict(required=True),
            source_type             = dict(default='image', choices=['image','image_volume','volume','volume_snapshot']),
            source_id               = dict(default=None, aliases=['image_id']),
            flavor_id               = dict(default=1),
            volume_size             = dict(default=None),
            key_name                = dict(default=None),
            availability_zone       = dict(default=None),
            security_groups         = dict(default='default', type='list'),
            netids                  = dict(default=None, type='list'),
            nics                    = dict(default=None),
            meta                    = dict(default=None, type='dict'),
            wait                    = dict(default=True, choices=BOOLEANS, type='bool'),
            wait_for                = dict(default=180),
            delete_on_termination   = dict(default=False, choices=BOOLEANS, type='bool'),
            state                   = dict(default='present', choices=['absent', 'present']),
            user_data               = dict(default=None, type='dict')
        ),
    )

    nova = nova_client.Client(module.params['login_username'],
                              module.params['login_password'],
                              module.params['login_tenant_name'],
                              module.params['auth_url'],
                              service_type='compute')
    try:
        nova.authenticate()
    except exceptions.Unauthorized as e:
        module.fail_json(msg = "Invalid OpenStack Nova credentials.: %s" % e.message)
    except exceptions.AuthorizationFailure as e:
        module.fail_json(msg = "Unable to authorize user: %s" % e.message)

    server = _find_server(module, nova)

    if module.params['state'] == 'present':
        if server:
            if server.status != 'ACTIVE':
                module.fail_json(msg="The VM is available but not Active. state:" + server.status)
            _return_server_and_exit(module, server, changed = False)
        else:
            _create_server(module, nova)
    elif server:
        _delete_server(module, nova, server)
    else:
        module.exit_json(changed = False, result = "absent")


main()
