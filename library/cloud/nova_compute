#!/usr/bin/python
#coding: utf-8 -*-

# (c) 2013, Benno Joy <benno@ansible.com>
# (c) 2013, John Dewey <john@dewey.ws>
#
# This module is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this software.  If not, see <http://www.gnu.org/licenses/>.
from copy import deepcopy
import time
try:
    from novaclient.v1_1 import client as nova_client
    from novaclient import exceptions as nova_exceptions
except ImportError:
    print("failed=True msg='novaclient is required for this module'")

try:
    from cinderclient.v1 import client as cinder_client
    from cinderclient import exceptions as cinder_exceptions
except ImportError:
    print("failed=True msg='cinderclient is required for this module'")
try:
    from neutronclient.v2_0 import client as neutron_client
except ImportError:
    print("failed=True msg='neutronclient is required for this module'")

DOCUMENTATION = '''
---
module: nova_compute
version_added: "1.2"
short_description: Create/Delete VMs from OpenStack
description:
   - Create or Remove virtual machines from Openstack.
options:
   os_username:
     description:
        - OpenStack Auth username
     required: true
     default: None
   os_password:
     description:
        - OpenStack Auth password
     required: true
     default: None
   os_tenant_name:
     description:
        - OpenStack Auth tenant name
     required: true
     default: None
   os_auth_url:
     description:
        - OpenStack Keystone Auth url
     required: true
     default: None
   region_name:
     description:
        - Name of the region
     required: false
     default: None
   state:
     description:
        - Indicate desired state of the resource
     choices: ['present', 'absent']
     default: present
   name:
     description:
        - Name that has to be given to the instance
     required: true
     default: None
   image_id:
     description:
        - The id of the image that has to be cloned
     required: false
     default: None
   image_name:
     description:
        - Name of image that has to be cloned
     required: false
     default: None
   flavor_id:
     description:
        - The id of the flavor in which the new VM has to be created
     required: false
     default: None
   flavor_name:
     description:
        - The name of the flavor in which the new VM has to be created
     required: false
     default: None
   key_name:
     description:
        - The key pair name to be used when creating a VM
     required: false
     default: None
   security_groups:
     description:
        - The name of the security group to which the VM should be added
     required: false
     default: None
   nics:
     description:
        - A list of network id's to which the VM's interface should be attached
     required: false
     default: None
   meta:
     description:
        - A list of key value pairs that should be provided as a metadata to the new VM
     required: false
     default: None
   wait:
     description:
        - If the module should wait for the VM to be created.
     required: false
     default: true
   timeout:
     description:
        - The amount of time the module should wait for the VM to get into active state
     required: false
     default: 180
   user_data:
     description:
        - Opaque blob of data which is made available to the instance
     required: false
     default: None
     version_added: "1.6"
requirements: ["novaclient", "cinderclient", "neutronclient"]
'''

EXAMPLES = '''
# Creates a new VM and attaches to a network and passes metadata to the instance
- nova_compute:
       state: present
       os_username: admin
       os_password: admin
       os_tenant_name: admin
       name: vm1
       image_id: 4f905f38-e52a-43d2-b6ec-754a13ffb529
       key_name: ansible_key
       timeout: 200
       flavor_id: 4
       nics:
         - net-id: 34605f38-e52a-25d2-b6ec-754a13ffb723
         - net-name: cloud
       meta:
         hostname: test1
         group: uge_master
       block_device_mapping:
        - volume_id: 34605f38-e52a-25d2-b6ec-754a13f13jad1
          device: /dev/vdb
          terminate_on_delete: True
'''

def _find_flavor(nova, flavor_name):
    for flav in nova.flavors.list():
        if flav.name == flavor_name:
            return flav.id
    return None

def _find_image(nova, image_name):
    for im in nova.images.list():
        if im.name == image_name:
            return im.id
    return None

def _find_volume(cinder, volume_name):
    for vol in cinder.volumes.list():
        if vol.display_name == volume_name:
            return vol.id
    return None

def _find_network(neutron, network_name):
    for net in neutron.list_networks()['networks']:
        if net['name'] == network_name:
            return net['id']
    return None

def _block_device_mapping(module, cinder):
    block = dict()
    for item in module.params['block_device_mapping']:
        volume_id = None
        if 'volume_name' in item.keys():
            volume_id = _find_volume(cinder, item['volume_name'])
        if 'volume_id' in item.keys():
            volume_id = item['volume_id']
        if volume_id is None:
            module.fail_json(msg='Cannot find volume:%s' % item)
        if 'device' not in item.keys():
            module.fail_json(msg='Cannot find device:%s' % item)
        block[item['device']] = volume_id + ':::'
        terminate = False
        if 'terminate_on_delete' in item.keys():
            if item['terminate_on_delete']:
                terminate = True
        if terminate:
            block[item['device']] += '1'
        else:
            block[item['device']] += '0'
    return block

def __nics(module, neutron):
    if not module.params['nics']:
        return None
    nics = []
    for item in module.params['nics']:
        i = deepcopy(item)
        if 'net-name' in item.keys():
            net_name = item.pop('net-name', None)
            net_id = _find_network(neutron, net_name)
            if not net_id:
                module.fail_json(msg='Cannot find network:%s' % net_name)
        if 'net-id' in item.keys():
            net_id = item['net-id']
        i['net-id'] = net_id
        nics.append(i)
    return nics

def __bootargs(module, nova):
    if module.params['flavor_name'] != None:
        flavor_id = _find_flavor(nova, module.params['flavor_name'])
    else:
        flavor_id = module.params['flavor_id']
    if not flavor_id:
        module.fail_json(msg='Flavor not found')
    if module.params['image_name'] != None:
        image_id = _find_image(nova, module.params['image_name'])
    else:
        image_id = module.params['image_id']
    if not image_id:
        module.fail_json(msg='Image not found')
    return [module.params['name'], image_id, flavor_id]


def _delete_server(module, nova):
    name = None
    server_list = None
    try:
        server_list = nova.servers.list(True, {'name': module.params['name']})
        if server_list:
            server = [x for x in server_list if x.name == module.params['name']]
            nova.servers.delete(server.pop())
    except nova_exceptions, e:
        module.fail_json(msg="Error in deleting vm: %s" % str(e))
    if module.params['wait'] == False:
        module.exit_json(changed = True, result = "deleted")
    expire = time.time() + int(module.params['timeout'])
    while time.time() < expire:
        name = nova.servers.list(True, {'name': module.params['name']})
        if not name:
            module.exit_json(changed = True, result = "deleted")
        time.sleep(5)
    module.fail_json(msg = "Timed out waiting for server to get deleted, please check manually")


def _create_server(module, nova, cinder, neutron):
    bootargs = __bootargs(module, nova)
    block_mapping = None
    if module.params['block_device_mapping']:
        block_mapping = _block_device_mapping(module, cinder)
    nics = __nics(module, neutron)
    bootkwargs = {
                'nics' : nics,
                'meta' : module.params['meta'],
                'key_name': module.params['key_name'],
                'security_groups': module.params['security_groups'].split(','),
                #userdata is unhyphenated in novaclient, but hyphenated here for consistency with the ec2 module:
                'userdata': module.params['user_data'],
                'block_device_mapping' : block_mapping,
    }
    if not module.params['key_name']:
        del bootkwargs['key_name']
    try:
        server_id = nova.servers.create(*bootargs, **bootkwargs)
        server = nova.servers.get(server_id)
    except nova_exceptions, e:
        module.fail_json(msg="Error in creating instance: %s " % str(e))
    if module.params['wait'] == True:
        expire = time.time() + int(module.params['timeout'])
        while time.time() < expire:
            try:
                server = nova.servers.get(server.id)
            except nova_exceptions, e:
                    module.fail_json(msg="Error in getting info from instance: %s" % str(e))
            if server.status == 'ACTIVE':
                private = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if 'OS-EXT-IPS:type' in x and x['OS-EXT-IPS:type'] == 'fixed']
                public  = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if 'OS-EXT-IPS:type' in x and x['OS-EXT-IPS:type'] == 'floating']
                module.exit_json(changed = True, id = server.id, private_ip=''.join(private), public_ip=''.join(public), status = server.status, info = server._info)
            if server.status == 'ERROR':
                module.fail_json(msg = "Error in creating the server, please check logs")
            time.sleep(2)

        module.fail_json(msg = "Timeout waiting for the server to come up.. Please check manually")
    if server.status == 'ERROR':
            module.fail_json(msg = "Error in creating the server.. Please check manually")
    private = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'fixed']
    public  = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'floating']
    module.exit_json(changed = True, id = info['id'], private_ip=''.join(private), public_ip=''.join(public), status = server.status, info = server._info)


def _get_server_state(module, nova):
    server = None
    try:
        servers = nova.servers.list(True, {'name': module.params['name']})
        if servers:
            # the {'name': module.params['name']} will also return servers
            # with names that partially match the server name, so we have to
            # strictly filter here
            servers = [x for x in servers if x.name == module.params['name']]
            if servers:
                server = servers[0]
    except nova_exceptions, e:
        module.fail_json(msg="Error in getting the server list: %s" % str(e))
    if server and module.params['state'] == 'present':
        if server.status != 'ACTIVE':
            module.fail_json( msg="The VM is available but not Active. state:" + server.status)
        private = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if 'OS-EXT-IPS:type' in x and x['OS-EXT-IPS:type'] == 'fixed']
        public  = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if 'OS-EXT-IPS:type' in x and x['OS-EXT-IPS:type'] == 'floating']
        module.exit_json(changed = False, id = server.id, public_ip = ''.join(public), private_ip = ''.join(private), info = server._info)
    if server and module.params['state'] == 'absent':
        return True
    if module.params['state'] == 'absent':
        module.exit_json(changed = False, result = "not present")
    return True



def main():
    module = AnsibleModule(
        argument_spec                   = dict(
        os_username                  = dict(required=True),
        os_password                  = dict(required=True),
        os_tenant_name               = dict(required=True),
        os_auth_url                  = dict(required=True),
        region_name                  = dict(default=None),
        name                         = dict(required=True),
        image_id                     = dict(default=None),
        flavor_id                    = dict(default=None),
        image_name                   = dict(default=None),
        flavor_name                  = dict(default=None),
        key_name                     = dict(default=None),
        security_groups              = dict(default='default'),
        nics                         = dict(default=None),
        meta                         = dict(default=None),
        wait                         = dict(default=True, choices=[True, False]),
        timeout                      = dict(default=180),
        state                        = dict(default='present', choices=['absent', 'present']),
        user_data                    = dict(default=None),
        block_device_mapping         = dict(default=None),
        ),
        mutually_exclusive = [['image_id', 'image_name'],
                              ['flavor_name', 'flavor_id']],
    )

    nova = nova_client.Client(module.params['os_username'],
                              module.params['os_password'],
                              module.params['os_tenant_name'],
                              module.params['os_auth_url'],
                              region_name=module.params['region_name'],
                              service_type='compute')
    cinder = cinder_client.Client(module.params['os_username'],
                                  module.params['os_password'],
                                  module.params['os_tenant_name'],
                                  module.params['os_auth_url'],
                                  region_name=module.params['region_name'])
    neutron = neutron_client.Client(username=module.params['os_username'],
                                    password=module.params['os_password'],
                                    tenant_name=module.params['os_tenant_name'],
                                    auth_url=module.params['os_auth_url'],
                                    region_name=module.params['region_name'])

    try:
        nova.authenticate()
    except nova_exceptions.Unauthorized, e:
        module.fail_json(msg = "Invalid OpenStack Nova credentials.: %s" % e.message)
    except nova_exceptions.AuthorizationFailure, e:
        module.fail_json(msg = "Unable to authorize user: %s" % e.message)
    try:
        cinder.authenticate()
    except cinder_exceptions.Unauthorized, e:
        module.fail_json(msg = "Invalid OpenStack Cinder credentials.: %s" % e.message)
    except cinder_exceptions.AuthorizationFailure, e:
        module.fail_json(msg = "Unable to authorize user: %s" % e.message)

    try:
        cinder.authenticate()
    except cinder_exceptions.Unauthorized, e:
        module.fail_json(msg = "Invalid OpenStack Cinder credentials.: %s" % e.message)
    except cinder_exceptions.AuthorizationFailure, e:
        module.fail_json(msg = "Unable to authorize user: %s" % e.message)

    if module.params['state'] == 'present':
        if not any([module.params['image_id'], module.params['image_name']]):
            module.fail_json( msg = "Parameter 'image_id' is required if state == 'present'")
        else:
            _get_server_state(module, nova)
            _create_server(module, nova, cinder, neutron)
    if module.params['state'] == 'absent':
        _get_server_state(module, nova)
        _delete_server(module, nova)

# this is magic, see lib/ansible/module.params['common.py
from ansible.module_utils.basic import *
main()
