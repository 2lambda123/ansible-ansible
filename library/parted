#!/usr/bin/python
# -*- coding: utf-8 -*-
DOCUMENTATION = '''
---
module: parted
short_description: Simple partition creator, geared towards fresh disk init
description:
     - This module can be used to create partitions of needed size on physical disks.
       The main idea is to intialize machines with lots of disks.
options:
  size:
    description:
      - Ensure that partition of this size exactly is created, will update facts if succesful
    required: false
    default: null
  minsize:
    description:
      - Ensure that partition of at least this size is created, will update facts if succesful
    required: false
    default: null
  minfree:
    description:
      - Ensure this amount of free space will be left after creating the partition
    required: false
    default: null
  repeated:
    description:
      - Will try to repeat the operation for each disk on the machine, otherwise stops on first success
    required: false
    default: no
    choices: [ "yes", "no" ]
notes:
    - All parameters are in MiB
      If partition cannot be created facts will not contain the C(parted_created) attribute
examples:
    - code: ansible all -s -m parted -a size=1024
      description: Will create the partition of exactly 1GiB in size, if possible
    - code: ansible all -s -m parted -a size=1024 minfree=1024
      description: Will create the partition of exactly 1GiB in size and leave at least 1GiB more as a free space
    - code: ansible all -s -m parted -a minsize=1024 minfree=1024
      description: Will create partition of at least 1GiB and leave at least 1GiB more as a free space 
author: Constantine Peresypkin
'''

MBYTE = 1024 * 1024

try:
    import json
except ImportError:
    import simplejson as json

def run_cmd(command):
    try:
        cmd = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = cmd.communicate()
    except (OSError, IOError), e:
        rc = 1
        err = str(e)
        out = ''
    except:
        rc = 1
        err = traceback.format_exc()
        out = ''
    else:
        rc = cmd.returncode
    return rc, out, err

def create(parted, disk, size=None, minsize=None, minfree=None, type=None, fs=None):
    if not type:
        type = parted.PARTITION_NORMAL
    const_min = None
    const_max = None
    if size:
        size *= MBYTE / disk.device.sectorSize
        const_min = size
        const_max = size
    elif minsize:
        minsize *= MBYTE / disk.device.sectorSize
        const_min = minsize
    const = parted.Constraint(device=disk.device)
    if not const_max:
        const_max = const.maxSize
    if not const_min:
        const_min = 0
    if const_max < const_min:
        return None
    if minfree:
        minfree *= MBYTE / disk.device.sectorSize
        max_length = 0
        space = None
        for f in disk.getFreeSpaceRegions():
            length = f.length - minfree
            if max_length < length:
                max_length = length
                space = f
        if not space:
            return None
        max_geom = parted.Geometry(device=disk.device, start=space.start, length=max_length)
        const2 = parted.Constraint(maxGeom=max_geom)
    else:
        const2 = parted.Constraint(startAlign=const.startAlign, endAlign=const.endAlign,
            startRange=const.startRange, endRange=const.endRange,
            minSize = const_min, maxSize=const_max)
    if fs:
        fs = parted.FileSystem(type=fs, geometry=const2.solveMax())
    part = parted.Partition(disk=disk, type=type, geometry=const2.solveMax(), fs=fs)
    try:
        disk.addPartition(partition=part, constraint=const2)
        disk.commit()
        created = {'number': part.number, 'path': part.path, 'start': part.geometry.start, 'end': part.geometry.end,
                   'size': part.geometry.length * disk['sector'], 'fs': part.fileSystem.type}
        return created
    except parted.PartitionException:
        return None

def create_fs(created, fs=None, fsopts=None):
    if not fs:
        return
    if 'ext3' in fs:
        cmd = 'mkfs.ext3'
    elif 'ext4' in fs:
        cmd = 'mkfs.ext4'
    elif 'xfs' in fs:
        if not os.path.exists('/sbin/mkfs.xfs'):
            module.fail_json(msg="Could not find mkfs.xfs. Please install xfsprogs package.")
        cmd = 'mkfs.xfs'
    else:
        return
    if fsopts:
        cmd = '%s %s' % (cmd, fsopts)
    cmd = '%s %s' % (cmd, created['path'])
    rc, out, err = run_cmd(cmd)
    if rc:
        module.fail_json(msg="'%s' failed: %s" % (cmd, err))
    else
        created['mkfs'] = True

def create_space(parted, size=None, minsize=None, minfree=None, fs=None, fsopts=None):
    disks = [parted.Disk(d) for d in parted.getAllDevices()]
    for d in disks:
        created = create(parted, d, size=size, minsize=minsize, minfree=minfree, fs=fs)
        if created:
            create_fs(created, fs=fs, fsopts=fsopts)
            return created
    return None


def main():
    global module
    module = AnsibleModule(
        argument_spec = dict(
            size=dict(default=None),
            minsize=dict(default=None),
            minfree=dict(default=None),
            repeated=dict(default='no', choices=['yes', 'no']),
            filesystem=dict(default=None, choices=['ext3', 'ext4', 'xfs']),
            fsoptions=dict(default=None)
        )
    )
    size = module.params['size']
    minsize = module.params['minsize']
    minfree = module.params['minfree']
    repeated = module.params['repeated']
    filesystem = module.params['filesystem']
    fsoptions = module.params['fsoptions']

    try:
        import parted
    except ImportError:
        module.fail_json(msg="Could not import python module: parted. Please install python-parted package.")
    created = None
    if size or minsize or minfree:
        created = [create_space(parted, size=size, minsize=minsize, minfree=minfree, fs=filesystem, fsopts=fsoptions)]
        while created:
            if 'no' in repeated:
                break
            created.append(create_space(parted, size=size, minsize=minsize, minfree=minfree, fs=filesystem, fsopts=fsoptions))
    data = {}
    if created:
        data['changed'] = True
        data['ansible_facts'] = {}
        data['ansible_facts']['parted_created'] = created
    module.exit_json(**data)

# this is magic, see lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>
main()

