#!/usr/bin/python -tt
# -*- coding: utf-8 -*-

# (c) 2012, Red Hat, Inc
# Written by Seth Vidal <skvidal at fedoraproject.org>
#
# This file is part of Ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
#


import traceback
import os
import subprocess

def_qf = "%{name}-%{version}-%{release}.%{arch}"
repoquery='/usr/bin/repoquery'
yumbin='/usr/bin/yum'
rpmbin = '/bin/rpm'

def is_installed(repoq, pkgspec, qf=def_qf):
    cmd = repoq + ["--disablerepo=*", "--pkgnarrow=installed", "--qf", qf, pkgspec]
    rc,out,err = run(cmd)
    if rc == 0:
        return [ p for p in out.split('\n') if p.strip() ]

    return []

def is_available(repoq, pkgspec, qf=def_qf):
    cmd = repoq + ["--qf", qf, pkgspec]
    rc,out,err = run(cmd)
    if rc == 0:
        return [ p for p in out.split('\n') if p.strip() ]

    return []


def is_update(repoq, pkgspec, qf=def_qf):
    cmd = repoq + ["--pkgnarrow=updates", "--qf", qf, pkgspec]
    rc,out,err = run(cmd)
    if rc == 0:
        return set([ p for p in out.split('\n') if p.strip() ])

    return []


def pkg_to_dict(pkgstr):
    if pkgstr.strip():
        n,e,v,r,a,repo = pkgstr.split('|')
    else:
        return {'error_parsing': pkgstr}

    d = {
        'name':n,
        'arch':a,
        'epoch':e,
        'release':r,
        'version':v,
        'repo':repo,
        'nevra': '%s:%s-%s-%s.%s' % (e,n,v,r,a)
        }

    if repo == 'installed':
        d['yumstate'] = 'installed'
    else:
        d['yumstate'] = 'available'

    return d

def repolist(repoq, qf="%{repoid}"):
    cmd = repoq + ["--qf", qf, "-a"]
    rc,out,err = run(cmd)
    ret = []
    if rc == 0:
        ret = set([ p for p in out.split('\n') if p.strip() ])

    return ret

def list_stuff(conf_file, stuff):
    qf = "%{name}|%{epoch}|%{version}|%{release}|%{arch}|%{repoid}"
    repoq = [repoquery, '--plugins', '--quiet', '-q']
    if conf_file and os.path.exists(conf_file):
        repoq += ['-c', conf_file]

    if stuff == 'installed':
        return [ pkg_to_dict(p) for p in is_installed(repoq, '-a', qf=qf) if p.strip() ]
    elif stuff == 'updates':
        return [ pkg_to_dict(p) for p in is_update(repoq, '-a', qf=qf) if p.strip() ]
    elif stuff == 'available':
        return [ pkg_to_dict(p) for p in is_available(repoq, '-a', qf=qf) if p.strip() ]
    elif stuff == 'repos':
        return [ dict(repoid=name, state='enabled') for name in repolist(repoq) if name.strip() ]
    else:
        return [ pkg_to_dict(p) for p in is_installed(repoq, stuff, qf=qf) + is_available(repoq, stuff, qf=qf) if p.strip() ]

def run(command):
    try:
        cmd = subprocess.Popen(command,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = cmd.communicate()
    except (OSError, IOError), e:
        rc = 1
        err = str(e)
        out = ''
    except:
        rc = 1
        err = traceback.format_exc()
        out = ''

        if out is None:
           out = ''
        if err is None:
           err = ''
    else:
        rc = cmd.returncode

    return rc, out, err

def install(module, items, yum_basecmd, latest=False):
    res = {'changed': False}

    if not latest:
        to_install = []
        for item in items:
            rc, out, err = run([rpmbin, "-q",  "--whatprovides", item])
            if rc != 0:
                to_install.append(item)
        if len(to_install) > 0:
            res['changed'] = True
    else:
        rc, out, err = run(yum_basecmd + ["check-update"] + items)
        if rc == 100:
            res['changed'] = True
            to_install = items
        elif rc != 0:
            module.exit_json(failed=True, msg=err)

    if len(to_install) > 0:
        rc, out, err = run(yum_basecmd + ["--obsoletes", "install"] + to_install)
        if rc != 0:
            module.exit_json(failed=True, msg=err)
        for item in to_install:
            rc, out, err = run([rpmbin, "-q",  "--whatprovides", item])
            if rc != 0:
                module.exit_json(failed=True, msg="%s could not be installed" % item)

    module.exit_json(**res)

def remove(module, items, yum_basecmd):
    res = {'changed': False}

    to_remove = []
    for item in items:
        rc, out, err = run([rpmbin, "-q",  "--whatprovides", "--qf", "%{NAME}\n", item])
        if rc == 0:
            to_remove.append(out.strip())
    if len(to_remove) > 0:
        res['changed'] = True
        rc, out, err = run(yum_basecmd + ["remove"] + to_remove)
        if rc != 0:
            module.exit_json(failed=True, msg=err)
        res['out'] = out
        res['err'] = err
        for item in to_remove:
            rc, out, err = run([rpmbin, "-q", item])
            if rc == 0:
                module.exit_json(failed=True, msg="%s was not removed" % item)

    module.exit_json(**res)

def ensure(module, state, pkgspec, conf_file):
    # take multiple args comma separated
    items = pkgspec.split(',')

    yum_basecmd = [yumbin, '-d', '1', '-y']
    if conf_file and os.path.exists(conf_file):
        yum_basecmd += ['-c', conf_file]

    if state in ['installed', 'present']:
        install(module, items, yum_basecmd)
    elif state in ['removed', 'absent']:
        remove(module, items, yum_basecmd)
    elif state == 'latest':
        install(module, items, yum_basecmd, latest=True)

    # should be caught by AnsibleModule argument_spec
    return dict(changed=False, failed=True, results='', errors='unexpected state')

def main():
    # state=installed pkg=pkgspec
    # state=removed pkg=pkgspec
    # state=latest pkg=pkgspec
    #
    # informational commands:
    #   list=installed
    #   list=updates
    #   list=available
    #   list=repos
    #   list=pkgspec

    module = AnsibleModule(
        argument_spec = dict(
            pkg=dict(aliases=['name']),
            # removed==absent, installed==present, these are accepted as aliases
            state=dict(default='installed', choices=['absent','present','installed','removed','latest']),
            list=dict(choices=['installed','updates','available','repos','pkgspec']),
            conf_file=dict(default=None),
        )
    )

    params = module.params


    if params['list'] and params['pkg']:
        module.fail_json(msg="expected 'list=' or 'name=', but not both")

    if params['list']:
        if not os.path.exists(repoquery):
            module.fail_json(msg="%s is required to use list= with this module. Please install the yum-utils package." % repoquery)
        results = dict(results=list_stuff(params['conf_file'], params['list']))
        module.exit_json(**results)

    else:
        pkg = params['pkg']
        if pkg is None:
            module.fail_json(msg="expected 'list=' or 'name='")
        else:
            state = params['state']
            res = ensure(module, state, pkg, params['conf_file'])
            module.fail_json(msg="we should never get here unless this all failed", **res)

# this is magic, see lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>

main()

