#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
Ansible module to add authorized_keys for ssh logins.
(c) 2012, Brad Olson <brado@movedbylight.com>

This file is part of Ansible

Ansible is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Ansible is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
"""

DOCUMENTATION = '''
---
module: authorized_key
short_description: Adds or removes an SSH authorized key
description:
     - Adds or removes an SSH authorized key for a user from a remote host.
version_added: "0.5"
options:
  user:
    description:
      - Name of the user who should have access to the remote host
    required: true
    default: null
    aliases: []
  key:
    description:
      - the SSH public key, as a string
    required: true
    default: null
  state:
    description:
      - whether the given key should or should not be in the file
    required: false
    choices: [ "present", "absent" ]
    default: "present"
  path:
    description:
      - the path to the authorized_keys file (AuthorizedKeysFile option in sshd_config)
    required: false
    default: .ssh/authorized_keys
  uid:
    description:
      - the uid of the directory and file if required
    default: -1 (which means the uid of the user)
  gid:
    description:
      - the gid of the directory and file if required
    default: -1 (which means the gid of the user)
  dir_perm:
    description:
      - the octal permissions for the directory containing the authorized_keys file
    default: 0600
  file_perm:
    description:
      - the octal permissions for the authorized_keys file
    default: 0700
examples:
   - code: 'authorized_key: user=charlie key="ssh-dss ASDF1234L+8BTwaRYr/rycsBF1D8e5pTxEsXHQs4iq+mZdyWqlW++L6pMiam1A8yweP+rKtgjK2httVS6GigVsuWWfOd7/sdWippefq74nppVUELHPKkaIOjJNN1zUHFoL/YMwAAAEBALnAsQN10TNGsRDe5arBsW8cTOjqLyYBcIqgPYTZW8zENErFxt7ij3fW3Jh/sCpnmy8rkS7FyK8ULX0PEy/2yDx8/5rXgMIICbRH/XaBy9Ud5bRBFVkEDu/r+rXP33wFPHjWjwvHAtfci1NRBAudQI/98DbcGQw5HmE89CjgZRo5ktkC5yu/8agEPocVjdHyZr7PaHfxZGUDGKtGRL2QzRYukCmWo1cZbMBHcI5FzImvTHS9/8B3SATjXMPgbfBuEeBwuBK5EjL+CtHY5bWs9kmYjmeo0KfUMH8hY4MAXDoKhQ7DhBPIrcjS5jPtoGxIREZjba67r6/P2XKXaCZH6Fc= charlie@example.org 2011-01-17"'
   - code: 'authorized_key: uid=0 gid=0 file_perm=0444 dir_perm=0755 path=/etc/ssh/%u-authorized_keys user=charlie key="ssh-dss ASDF1234L+8BTwaRYr/rycsBF1D8e5pTxEsXHQs4iq+mZdyWqlW++L6pMiam1A8yweP+rKtgjK2httVS6GigVsuWWfOd7/sdWippefq74nppVUELHPKkaIOjJNN1zUHFoL/YMwAAAEBALnAsQN10TNGsRDe5arBsW8cTOjqLyYBcIqgPYTZW8zENErFxt7ij3fW3Jh/sCpnmy8rkS7FyK8ULX0PEy/2yDx8/5rXgMIICbRH/XaBy9Ud5bRBFVkEDu/r+rXP33wFPHjWjwvHAtfci1NRBAudQI/98DbcGQw5HmE89CjgZRo5ktkC5yu/8agEPocVjdHyZr7PaHfxZGUDGKtGRL2QzRYukCmWo1cZbMBHcI5FzImvTHS9/8B3SATjXMPgbfBuEeBwuBK5EjL+CtHY5bWs9kmYjmeo0KfUMH8hY4MAXDoKhQ7DhBPIrcjS5jPtoGxIREZjba67r6/P2XKXaCZH6Fc= charlie@example.org 2011-01-17"'
     description: "Example from Ansible Playbooks"
   - code: "authorized_key: user=charlie key='$FILE(/home/charlie/.ssh/id_rsa.pub)'"
     description: "Shorthand available in Ansible 0.8 and later"
author: Brad Olson
'''

# Makes sure the public key line is present or absent in the user's .ssh/authorized_keys.
#
# Arguments
# =========
#    user = username
#    key = line to add to authorized_keys for user
#    state = absent|present (default: present)
#    path = path to authorized_keys file
#    uid = uid the authorized_keys should be set to
#    gid = gid the authorized_keys should be set to
#    file_perm = perms the authorized_keys file should be set to
#    dir_perm = perms the directory containing the authorized_keys file should be set to
#
# see example in examples/playbooks

import sys
import os
import pwd
import os.path
import tempfile
import shutil
import re
import string

def keyfile(module, user, path, uid, gid, file_perm, dir_perm, write=False):
    """
    Calculate name of authorized keys file, optionally creating the
    directories and file, properly setting permissions.

    :param str user: name of user in passwd file
    :param bool write: if True, write changes to authorized_keys file (creating directories if needed)
    :return: full path string to authorized_keys for user
    """

    try:
        user_entry = pwd.getpwnam(user)
    except KeyError, e:
        module.fail_json(msg="Failed to lookup user %s: %s" % (user, str(e)))
    homedir    = user_entry.pw_dir

    # See AuthorizedKeysFile in sshd_config(5)
    keysfile = re.sub(r'%u', user, path);
    keysfile = re.sub(r'%h', user, keysfile);
    keysfile = re.sub(r'%%', '%', keysfile);

    if not keysfile.startswith('/'):
        keysfile = os.path.join(homedir, keysfile)

    sshdir  = os.path.dirname(keysfile)

    if not write:
        return keysfile

    # Update these if they haven't been manually set
    if uid < 0:
        uid = user_entry.pw_uid
    if gid < 0:
        gid = user_entry.pw_gid

    if not os.path.exists(sshdir):
        os.mkdir(sshdir, dir_perm)
        if module.selinux_enabled():
            module.set_default_selinux_context(sshdir, False)
    os.chown(sshdir, uid, gid)
    os.chmod(sshdir, dir_perm)

    if not os.path.exists( keysfile):
        try:
            f = open(keysfile, "w") #touches file so we can set ownership and perms
        finally:
            f.close()
        if module.selinux_enabled():
            module.set_default_selinux_context(keysfile, False)

    os.chown(keysfile, uid, gid)
    os.chmod(keysfile, file_perm)
    return keysfile

def readkeys(filename):

    if not os.path.isfile(filename):
        return []
    f = open(filename)
    keys = [line.rstrip() for line in f.readlines()]
    f.close()
    return keys

def writekeys(module, filename, keys):

    fd, tmp_path = tempfile.mkstemp('', 'tmp', os.path.dirname(filename))
    f = open(tmp_path,"w")
    try:
        f.writelines( (key + "\n" for key in keys) )
    except IOError, e:
        module.fail_json(msg="Failed to write to file %s: %s" % (tmp_path, str(e)))
    f.close()
    module.atomic_replace(tmp_path, filename)

def enforce_state(module, params):
    """
    Add or remove key.
    """

    user  = params["user"]
    key   = params["key"]
    state = params.get("state", "present")
    path  = params["path"]
    uid   = string.atoi(params["uid"], 8)
    gid   = string.atoi(params["gid"], 8)
    file_perm = string.atoi(params["file_perm"], 8)
    dir_perm = string.atoi(params["dir_perm"], 8)

    # check current state -- just get the filename, don't create file
    params["keyfile"] = keyfile(module, user, path, uid, gid, file_perm, dir_perm, write=False)
    keys = readkeys(params["keyfile"])
    present = key in keys

    # handle idempotent state=present
    if state=="present":
        if present:
            module.exit_json(changed=False)
        keys.append(key)
        writekeys(module, keyfile(module, user, path, uid, gid, file_perm, dir_perm, write=True), keys)

    elif state=="absent":
        if not present:
            module.exit_json(changed=False)
        keys.remove(key)
        writekeys(module, keyfile(module, user, path, uid, gid, file_perm, dir_perm, write=True), keys)

    params['changed'] = True
    return params

def main():

    module = AnsibleModule(
        argument_spec = dict(
           user  = dict(required=True),
           key   = dict(required=True),
           state = dict(default='present', choices=['absent','present']),
           path  = dict(default='.ssh/authorized_keys'),
           uid   = dict(default='-1'),
           gid   = dict(default='-1'),
           file_perm = dict(default='0600'),
           dir_perm = dict(default='0700'),
        )
    )

    params = module.params
    results = enforce_state(module, module.params)
    module.exit_json(**results)

# this is magic, see lib/ansible/module_common.py
#<<INCLUDE_ANSIBLE_MODULE_COMMON>>
main()
