from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

DOCUMENTATION = '''
  callback: csv
  callback_type: stdout
  requirements:
    - Whitelist in the configuration.
  short_description: Helps generate CSV output.
  version_added: "2.10"
  description:
    - Helps generate output in CSV format.
    - Meant to be used for plays producing CSV output on the STDOUT (e.g. via
      M(raw) module). The output must be either valid CSV format or it has to
      fail. That means that no empty sting must be returned.
  options:
    fields:
      description:
        - List of CSV fields. Each item must contain at least the C(name)
          definition. Optionally, it's possible to define a C(placeholder)
          which gets replaced by real value and C(in_message) indicating if
          that field is expected to be contained in the message in the case of
          C(ok) state.
        - "The following placeholders are supported: C(%n) for the inventory
          name, C(%h) for the C(ansible_host) value, C(%s) for the status
          (C(ok), C(unreachable), C(failed)), C(%g) for the longest group name,
          C(%m) for message content (applicable only for C(ok) state) and C(%v)
          for Ansible variable name."
      type: list
      default:
        - name: host
          placeholder: "%n"
        - name: ip
          placeholder: "%h"
        - name: status
          placeholder: "%s"
        - name: group
          placeholder: "%g"
      ini:
        - section: callback_csv
          key: fields
      env:
        - name: ANSIBLE_CALLBACK_CSV_FIELDS
    format_ko:
      description:
        - Format of the string shown when the host is in C(unreachable) or
          C(failed) state. By default it's autogenerated from the C(fields) and
          the C(separator) options. With the default C(fields) and
          C(separator), it's C(%n,%h,%s,%g).
      type: str
      default: "<autogenerated>"
      ini:
        - section: callback_csv
          key: format_ko
      env:
        - name: ANSIBLE_CALLBACK_CSV_FORMAT_KO
    format_ok:
      description:
        - Format of the string shown when the host is in C(ok) state.
      type: str
      default: "%n,%s"
      ini:
        - section: callback_csv
          key: format_ok
      env:
        - name: ANSIBLE_CALLBACK_CSV_FORMAT_OK
    generate_header:
      description:
        - Whether to generate CSV header.
      type: boolean
      default: yes
      ini:
        - section: callback_csv
          key: generate_header
      env:
        - name: ANSIBLE_CALLBACK_CSV_GENERATE_HEADER
    ansible_host_alt:
      description: Alternative variable holding the host IP when the
        C(ansible_host) variable is not defined. Should be defined on the
        inventory level to have it accessible even when host is unreachable.
      default: null
      ini:
        - section: callback_csv
          key: ansible_host_alt
      env:
        - name: ANSIBLE_CALLBACK_CSV_ANSIBLE_HOST_ALT
    separator:
      description:
        - CSV separator.
      type: str
      default: ","
      ini:
        - section: callback_csv
          key: separator
      env:
        - name: ANSIBLE_CALLBACK_CSV_SEPARATOR
'''

EXAMPLES = '''
examples: |
  ### Default usage
  export ANSIBLE_LOAD_CALLBACK_PLUGINS=1
  export ANSIBLE_STDOUT_CALLBACK=csv
  ansible all -i localhost, -c local -m raw -a "echo ','" | tee report.csv

  ### Customized usage
  # Let's have a script called facts.sh that produces the following output
  my.hostname.com,192.168.1.123,centos,7,4,3881048

  # Then we can configure Ansible to use custom CSV fields by adding the
  # following into ansible.cfg:

  [callback_csv]
  fields = [
      {'placeholder': '%n', 'name': 'name'},
      {'name': 'host', 'in_message': True},
      {'placeholder': '%h', 'name': 'ip', 'in_message': True},
      {'name': 'distro', 'in_message': True},
      {'name': 'version', 'in_message': True},
      {'name': 'cpu', 'in_message': True},
      {'name': 'mem', 'in_message': True},
      {'placeholder': '%s', 'name': 'status'},
      {'placeholder': '%g', 'name': 'group'},
      {'placeholder': '%v', 'variable': 'inventory_hostname_short', 'name': 'short'}]
  format_ok = %n,%m,%s,%g,%v

  # Then we can run Ansible with CSV output liek this:
  export ANSIBLE_LOAD_CALLBACK_PLUGINS=1
  export ANSIBLE_STDOUT_CALLBACK=csv
  ansible all -i localhost, -c local -m raw \
    -a "echo $(cat ./facts.sh | base64 -w0) | python -m base64 -d > ./facts.sh && chmod +x ./facts.sh && ./facts.sh" | \
  tee report.csv

  # The output of such run will be (the stats at the end are printed into STDERR
  # so they are not in the file):
  name,hostname,ip,distro,version,cpu,mem,status,group,type
  localhost,my.hostname.com,192.168.1.123,centos,7,4,3881048,ok,ungrouped,localhost

  TOTAL: 1
  OK: 1
  FAILED: 0
  UNREACHABLE: 0

  # We can also display the file in table format:
  column -t -s ',' report.csv
'''


from ansible.plugins.callback import CallbackBase
from ansible import constants as C
from ansible.module_utils.six import text_type
import re
import yaml


class CallbackModule(CallbackBase):
    CALLBACK_NAME = 'csv'
    CALLBACK_TYPE = 'stdout'
    CALLBACK_VERSION = 2.0
    CALLBACK_NEEDS_WHITELIST = True

    def __init__(self):
        super(CallbackModule, self).__init__()

        self.FIELDS = None
        self.FORMAT_KO = ""
        self.FORMAT_OK = ""

    def _get_longest_group(self, groups):
        group = ""

        for g in groups:
            if (
                    '@template-' not in g.name and
                    not g.name.endswith('.vault') and
                    len(g.name) > len(group)):
                group = g.name

        return group

    def _get_vars_key_value(self, vars, key):
        vk_exists = False
        vv = None

        path = key.split('.')

        # Test the path
        for p in path:
            # Test if the path is a ref to a list's item
            m = re.match(r'(.*)\[(\d+)\]$', p)
            idx = None

            if m is not None and len(m.groups()) == 2:
                p = m.group(1)
                idx = int(m.group(2))

            if p in vars:
                vars = vars[p]

                if idx is not None:
                    if isinstance(vars, list) and len(vars) > abs(idx):
                        vars = vars[idx]
                    else:
                        break
            else:
                break
        else:
            # This gets applied only when loop succesfully finished
            vv = vars
            vk_exists = True

        return vk_exists, vv

    def _replace(self, result, status, format=None, msg=None):
        if msg is None:
            FMT = self.FORMAT_KO
        else:
            FMT = self.FORMAT_OK

        # Generate the default format
        if format is None and FMT == "":
            f_len = len(self.FIELDS)

            for n, field in enumerate(self.FIELDS):
                if (
                        'placeholder' in field and
                        len(field['placeholder']) == 2 and
                        field['placeholder'].startswith("%")):
                    FMT += field['placeholder']

                if n != f_len - 1:
                    FMT += self.get_option('separator')
        if msg is None:
            self.FORMAT_KO = FMT
        else:
            self.FORMAT_OK = FMT

        if format is None:
            format = FMT

        # Replace placeholders
        format = format.replace(
            "%n", result._host.get_name())
        format = format.replace(
            "%s", status)
        format = format.replace(
            "%g", self._get_longest_group(result._host.get_groups()))

        ansible_host_alt = self.get_option('ansible_host_alt')

        if 'ansible_host' in result._host.get_vars():
            format = format.replace(
                "%h", result._host.get_vars().get('ansible_host'))
        elif (
                ansible_host_alt is not None and
                ansible_host_alt in result._host.get_vars()):
            format = format.replace(
                "%h", result._host.get_vars().get(ansible_host_alt))

        # Special replacement for variable placeholders
        for field in self.FIELDS:
            if (
                    'placeholder' in field and
                    field['placeholder'] == '%v' and
                    'variable' in field):
                vk_exists, vv = self._get_vars_key_value(
                    result._host.get_vars(), field['variable'])

                if not vk_exists:
                    vv = ''

                format = format.replace("%v", vv, 1)

        if msg is not None:
            format = format.replace("%m", msg)

        return format

    def v2_playbook_on_play_start(self, play):
        fields = self.get_option('fields')

        # Turn list of strings into real data structure
        if (
                self.FIELDS is None and
                len(fields) and
                isinstance(fields[0], text_type)):
            fields = ', '.join(fields)
            fields = yaml.safe_load(fields)

        self.FIELDS = fields

        # Generate CSV header
        if self.get_option('generate_header'):
            msg = self.get_option('separator').join(
                [i['name'] for i in self.FIELDS])

            self._display.display(msg, color=C.COLOR_HIGHLIGHT)

    def v2_runner_on_ok(self, result):
        msg = ""

        for line in result._result.get('stdout_lines', []):
            # Accept only CSV-like lines
            if self.get_option('separator') in line:
                msg += line.rstrip()

        if len(msg) > 0:
            msg = self._replace(
                result, "ok", self.get_option('format_ok'), msg)

            self._display.display(msg, color=C.COLOR_OK)
        else:
            self._display.warning("No message from %s." % result._host)

            msg = self._replace(result, "failed")

            self._display.display(msg, color=C.COLOR_ERROR)

    def v2_runner_on_failed(self, result, ignore_errors=False):
        msg = self._replace(result, "failed")

        self._display.display(msg, color=C.COLOR_ERROR)

    def v2_runner_on_unreachable(self, result):
        msg = self._replace(result, "unreachable")

        self._display.display(msg, color=C.COLOR_DEPRECATE)

    def v2_playbook_on_stats(self, stats):
        self._display.display("\nTOTAL: %d" % (
            len(stats.dark) + len(stats.failures) + len(stats.ok)),
            stderr=True)
        self._display.display(
            "OK: %d" % len(stats.ok),
            color=C.COLOR_OK,
            stderr=True)
        self._display.display(
            "FAILED: %d" % len(stats.failures),
            color=C.COLOR_ERROR,
            stderr=True)
        self._display.display(
            "UNREACHABLE: %d" % len(stats.dark),
            color=C.COLOR_DEPRECATE,
            stderr=True)
