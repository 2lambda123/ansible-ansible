#!/usr/bin/python

# (c) 2018, Sven Wisotzky
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function
__metaclass__ = type

ANSIBLE_METADATA = {
    'metadata_version': '1.1',
    'status': ['preview'],
    'supported_by': 'community'
}

DOCUMENTATION = '''
---
module: netconf_get
author: "Sven Wisotzky"
short_description: Ansible module to execute NETCONF <get> or <get-config> requests
description:
    - NETCONF is a network management protocol developed and standardized by
      the IETF. It is documented in RFC 6241.
    - This module allows the user to read information using NETCONF.
notes:
    - This module supports reading from startup, running and candidate datastores.
      If no datastore is specified, it will execute a <get> request to retrieve
      operational state data.
    - This module support the use of connection=netconf and connection=local.
    - This module supports both xpath and subtree filters as per RFC6241.
      Remind that NETCONF xpath filters will ignore xml namespaces, while
      for NETCONF subtree filters xmlns are enforced.
    - If the device does not support the :xpath feature, this module is executing
      an unfiltered <get> respectively <get-config> request. The response will
      be filtered by the Ansible module afterwards by executing the xpath
      expression. This post-filtering comes with the limitation, that all
      objects found will be simply appended to the <data> root element.
version_added: "2.5"
options:
  host:
    description:
     - the hostname or ip address of the netconf device
     - not needed, in case of connection=netconf
     - if specified, a dedicated connection will be build
    required: false
  port:
    description:
     - the netconf port
    default: 830
    required: false
  hostkey_verify:
    description:
     - if true, the ssh host key of the device must match a ssh key present on the host
     - if false, the ssh host key of the device is not checked
    default: true
    required: false
  look_for_keys:
    description:
     - if true, enables looking in the usual locations for ssh keys (e.g. ~/.ssh/id_*)
     - if false, disables looking for ssh keys
    default: true
    required: false
  allow_agent:
    description:
     - if true, enables querying SSH agent (if found) for keys
     - if false, disables querying the SSH agent for ssh keys
    default: true
    required: false
  username:
    description:
     - the username to authenticate with
    required: true
  password:
    description:
     - password of the user to authenticate with
    required: true
  datastore:
    description:
     - choice of candidate, running, startup
     - if specified, a <get-config> request is issued
     - if not specified, a <get> request is issued
    default: running
    required: false
  filter:
    description:
     - choice of XPATH or subtree filter
    required: false
  format:
    description:
     - choice of json or xml
    default: json

requirements:
  - "python >= 2.6"
  - "ncclient"
  - "jxmlease"
  - "lxml.etree"
'''

EXAMPLES = '''
- name: get configuration
  netconf_get:
    datastore: candidate

- name: get schema list using xpath  
  netconf_get:
    host: "{{ inventory_hostname }}"
    username: "{{ hostvars[inventory_hostname].ansible_user }}"
    password: "{{ hostvars[inventory_hostname].ansible_ssh_pass }}"
    filter: netconf-state/schemas/schema
    format: xml
    hostkey_verify: false

- name: get netconf statistics using subtree filtering
  netconf_get:
    host: "{{ inventory_hostname }}"
    username: "{{ hostvars[inventory_hostname].ansible_user }}"
    password: "{{ hostvars[inventory_hostname].ansible_ssh_pass }}"
    filter: <netconf-state xmlns="urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"><statistics/></netconf-state>
    hostkey_verify: false
'''

RETURN = '''
data:
    description: result of the <get> or <get-config> request
    returned: success
    type: dictionary
    sample: "data": { "netconf-state": { "statistics": { "dropped-sessions": "1", "in-bad-hellos": "0", "in-bad-rpcs": "3", "in-rpcs": "318", "in-sessions": "145", "netconf-start-time": "2018-04-23T09:07:22+02:00", "out-notifications": "0", "out-rpc-errors": "9" } } } 

server_capabilities:
    description: list of capabilities of the server
    returned: success
    type: list
    sample: ['urn:ietf:params:netconf:base:1.1','urn:ietf:params:netconf:capability:confirmed-commit:1.0','urn:ietf:params:netconf:capability:candidate:1.0']
'''

import sys
import traceback
import lxml.etree

try:
    import ncclient.manager
    HAS_NCCLIENT = True
except ImportError:
    HAS_NCCLIENT = False

try:
    import jxmlease
    HAS_JXMLEASE = True
except ImportError:
    HAS_JXMLEASE = False


from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils._text import to_native
from ansible.module_utils.connection import Connection, ConnectionError

# --- helpers -----------------------------------------------------------

def transform_reply():
    reply = '''<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="xml" indent="no"/>

    <xsl:template match="/|comment()|processing-instruction()">
        <xsl:copy>
            <xsl:apply-templates/>
        </xsl:copy>
    </xsl:template>

    <xsl:template match="*">
        <xsl:element name="{local-name()}">
            <xsl:apply-templates select="@*|node()"/>
        </xsl:element>
    </xsl:template>

    <xsl:template match="@*">
        <xsl:attribute name="{local-name()}">
            <xsl:value-of select="."/>
        </xsl:attribute>
    </xsl:template>
    </xsl:stylesheet>
    '''
    if sys.version < '3':
        return reply
    else:
        return reply.encode('UTF-8')

def xpath(xml, filter):
    xmldom = lxml.etree.fromstring(xml)
    xsltdom = lxml.etree.fromstring(transform_reply())
    newdom = lxml.etree.XSLT(xsltdom)(xmldom)

    resultdom = lxml.etree.Element('data')

    items = newdom.xpath(filter)
    for i in items:
        resultdom.append(i)

    result = lxml.etree.tostring(resultdom, pretty_print=True)
    return result

# --- main() ------------------------------------------------------------

def main():
    module = AnsibleModule(
        argument_spec=dict(
            datastore=dict(choices=['startup', 'candidate', 'running']),
            filter=dict(type='str'),
            format=dict(choices=['xml', 'json'], default='json'),
            
            # connection arguments, not needed if using connection=netconf
            host=dict(type='str'),
            port=dict(type='int', default=830),
            username=dict(type='str', no_log=True),
            password=dict(type='str', no_log=True),
            hostkey_verify=dict(type='bool', default=True),
            look_for_keys=dict(type='bool', default=True),
            allow_agent=dict(type='bool', default=True),
        ),
    )
    if module.params['format']=='json':
        if not HAS_JXMLEASE:
            module.fail_json(msg='jxmlease is required but does not appear to be installed. '
                                 'It can be installed using `pip install jxmlease`')

    if not module._socket_path:
        # [1] need to connect to NETCONF server (connection=local)
        if not HAS_NCCLIENT:
            module.fail_json(msg='ncclient is required but does not appear to be installed. '
                                 'It can be installed using `pip install ncclient`')

        nckwargs = dict(
            host=module.params['host'],
            port=module.params['port'],
            hostkey_verify=module.params['hostkey_verify'],
            allow_agent=module.params['allow_agent'],
            look_for_keys=module.params['look_for_keys'],
            username=module.params['username'],
            password=module.params['password'],
        )

        try:
            m = ncclient.manager.connect(**nckwargs)
            server_capabilities = list(m.server_capabilities)
        except ncclient.transport.errors.AuthenticationError:
            module.fail_json(msg='authentication failed while connecting to device')
        except Exception as e:
            module.fail_json(msg='error connecting to the device: %s' % to_native(e), exception=traceback.format_exc())

        local_connection = True
    else:
        # [2] reuse existing NETCONF connection (connection=netconf)
        m = Connection(module._socket_path)
        capabilities = module.from_json(m.get_capabilities())
        server_capabilities = capabilities.get('server_capabilities')
        local_connection = False

    datastore = module.params['datastore']
    caps = '\n'.join(server_capabilities)

    if datastore=='candidate' and not ':candidate' in caps:
        if local_connection:
            m.close_session()
        module.fail_json(msg=':candidate is not supported by this netconf server')

    if datastore=='startup' and not ':startup' in caps:
        if local_connection:
            m.close_session()
        module.fail_json(msg=':startup is not supported by this netconf server')

    filter = None
    post_filter = None

    if module.params['filter']:
        try:
            if sys.version < '3':
                f = lxml.etree.fromstring(module.params['filter'])
            else:
                f = lxml.etree.fromstring(module.params['filter'].encode('UTF-8'))

            if local_connection:
                filter = ('subtree', f)
            else:
                # Ansible connection infra is unable to serialize the
                # lxml.etree.Element containing the filter.
                # Falling back to string attribute.
                filter = '<filter xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">%s</filter>' % module.params['filter']

        except lxml.etree.XMLSyntaxError:
            if ':xpath' in caps:
                if local_connection:
                    filter = ('xpath', module.params['filter'])
                else:
                    # Ansible connection infra is unable to serialize the tuple
                    # containing the filter. Falling back to string attribute.
                    filter = '<filter xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" type="xpath" select="%s">' % module.params['filter']
            else:
                post_filter = module.params['filter']
      
    try:
        if datastore:
            m.lock(target=datastore)
            if local_connection:
                xmlresp = m.get_config(source=datastore, filter=filter).data_xml
            else:
                # Ansible connection infra does directly provide the
                # result string. Need to remove the "data_xml".
                xmlresp = m.get_config(source=datastore, filter=filter)
        else:
            if local_connection:
                xmlresp = m.get(filter=filter).data_xml
            else:
                # Ansible connection infra does directly provide the
                # result string. Need to remove the "data_xml".
                xmlresp = m.get(filter=filter)

    except Exception as e:
        module.fail_json(msg='error executing <get>/<get-config> request: %s' % to_native(e), exception=traceback.format_exc())

    finally:
        if datastore:
            m.unlock(target=datastore)
        if local_connection:
            m.close_session()

    retkwargs = dict()
    try:
        if post_filter:
            xmlresp = xpath(xmlresp, post_filter)

        if module.params['format']=='json':
            jsonresp = jxmlease.parse(xmlresp)
            retkwargs = jsonresp
        else:
            retkwargs['data'] = xmlresp

    except Exception as e:
        module.fail_json(msg='error processing <get>/<get-config> response: %s' % to_native(e), exception=traceback.format_exc())

    retkwargs['server_capabilities'] = server_capabilities
    module.exit_json(changed=False, **retkwargs)


if __name__ == '__main__':
    main()
